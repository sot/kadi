"""
Provide functions for dynamically determining Chandra commanded states.

This is based entirely on known history of commands.
"""

import collections
import contextlib
import dataclasses
import inspect
import itertools
import re
from typing import Callable

import astropy.units as u
import chandra_maneuver
import numpy as np
import ska_sun
from astropy.table import Row as TableRow
from astropy.table import Table
from chandra_time import DateTime, date2secs, secs2date
from cxotime import CxoTime
from Quaternion import Quat

from kadi import commands

# Registry of Transition classes that can update a state key. A given state key
# transition may be generated by several different transition classes, hence the
# dict value is a list. Note that some state keys are coupled. For example for OTG
# states ["letg", "hetg", "grating"] are always all updated together, so if you ask for
# "letg" the code computes all three.  PCAD_STATE_KEYS are another example.
#
# >>> kadi.commands.states.TRANSITIONS["hetg"]
# [kadi.commands.states.HETG_INSR_Transition,  # directly impacts hetg
#  kadi.commands.states.HETG_RETR_Transition,
#  kadi.commands.states.LETG_INSR_Transition,  # coupled state
#  kadi.commands.states.LETG_RETR_Transition]
TRANSITIONS: dict[str, list[type]] = collections.defaultdict(list)

# Set of all BaseTransition subclasses
TRANSITION_CLASSES: set[type] = set()

# Dict of {state_key: CompState} classes. This maps state keys to the computed state
# class that provides the state key.
COMP_STATES: dict[str, type] = {}

# Ordered list of all available state keys
STATE_KEYS = []

# Quaternion componenent names
QUAT_COMPS = ["q1", "q2", "q3", "q4"]

# State keys for PCAD-related transitions.  If *any* of these are requested then
# *all* of them need to be processed to get the correct answer.
PCAD_STATE_KEYS = (
    QUAT_COMPS
    + ["targ_" + qc for qc in QUAT_COMPS]
    + ["auto_npnt", "pcad_mode", "sun_vector_update"]
)

# State keys for SPM-related transitions.
SPM_STATE_KEYS = ["sun_pos_mon", "battery_connect", "eclipse_enable_spm"]

# Default state keys (mostly matches classic command states list)
DEFAULT_STATE_KEYS = (
    "ccd_count",
    "clocking",
    "dec",
    "dither",
    "fep_count",
    "hetg",
    "letg",
    "obsid",
    "off_nom_roll",
    "pcad_mode",
    "pitch",
    "power_cmd",
    "q1",
    "q2",
    "q3",
    "q4",
    "ra",
    "roll",
    "si_mode",
    "simfa_pos",
    "simpos",
    "targ_q1",
    "targ_q2",
    "targ_q3",
    "targ_q4",
    "vid_board",
)

# {TLMSID: SI_MODE} mapping for SI modes that have special handling in state transitions
NIL_SIMODES = {
    "WT00DAA014": "H2C_0002",
    "WT00D96014": "H2C_0001",
    "WT00D98014": "H1C_0001",
    "WT00452024": "HIE_0002",
    "WT0023C024": "HSE_0002",
    "WT0023A024": "HSO_0002",
    "WT00D06014": "HIE_0003",
    "WT00D0A014": "HSE_0003",
    "WT00D08014": "HSO_0003",
}


@contextlib.contextmanager
def disable_grating_move_duration():
    """
    Temporarily disable the grating move duration
    """
    apply_move_duration = MechMove.apply_move_duration
    MechMove.apply_move_duration = False
    yield
    MechMove.apply_move_duration = apply_move_duration


class Transition(dict):
    """
    Dict of transitions at a given date.

    This is a dict of {state_key: state_val} where state_val is either a value
    or a TransitionCallback object.

    When creating a TransitionCallback object, you can optionally supply two additional
    positional arguments: the date (str) and the constraint (function).

    The constraint function must take a single argument, the state dict, and return
    True if the transition is allowed and False otherwise. For example::

      def constraint(state):
            return state["pcad_mode"] == "NMAN"

      transition = Transition("2010:001:00:00:00", constraint=constraint)
    """

    date: str | None = None
    constraint: Callable | None = None

    def __init__(self, *args, **kwargs):
        if args and isinstance(args[0], str):
            self.date = args[0]
            args = args[1:]
        if args and callable(args[0]):
            self.constraint = args[0]
            args = args[1:]
        super().__init__(*args, **kwargs)

    def __repr__(self):
        return f"{self.date}: {super().__repr__()}"

    def __eq__(self, other):
        return self.date == other.date and super().__eq__(other)


class NoTransitionsError(ValueError):
    """No transitions found within commands"""


class TransKeysSet(set):
    """Like set() but with more compact str output for table printing"""

    def __str__(self):
        return ",".join(sorted(self))

    def __and__(self, other):
        return TransKeysSet(super().__and__(other))


class StateDict(dict):
    """
    Dict for state key/val pairs.

    When a key value is set the key is stored in the trans_keys attribute.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.trans_keys = TransKeysSet()

    def __setitem__(self, key, val):
        super().__setitem__(key, val)
        self.trans_keys.add(key)

    def copy(self):
        """Copy without trans_keys"""
        return StateDict(self)


@dataclasses.dataclass
class TransitionCallback:
    """
    Callback function for a transition.

    This is used to store the callback function and any additional keyword arguments.
    """

    callback: callable
    kwargs: dict = dataclasses.field(default_factory=dict)


###################################################################
# Transition base classes
###################################################################


class AutoDocMixin:
    @classmethod
    def _auto_update_docstring(cls):
        """
        Put some useful information at the top of docstring.
        """
        docs = []
        docs.append("*State keys*: " + ", ".join(cls.state_keys))

        if hasattr(cls, "command_attributes"):
            cmd_attrs = []
            for key, val in cls.command_attributes.items():
                cmd_attrs.append("{}={}".format(key, val))

            if hasattr(cls, "command_params"):
                keys_list = list(cls.command_params.keys())
                vals_list = [
                    val if isinstance(val, list) else [val]
                    for val in cls.command_params.values()
                ]
                for key, vals in zip(keys_list, vals_list):
                    valstr = " or ".join(str(val) for val in vals)
                    cmd_attrs.append("{}={}".format(key, valstr))

            docs.append("")
            docs.append("*Commands*: " + ", ".join(cmd_attrs))

        others = []
        for attr, val in cls.__dict__.items():
            if (
                attr.startswith("_")
                or inspect.ismethod(val)
                or attr in ("state_keys", "command_attributes", "command_params")
            ):
                continue
            others.append("{}={}".format(attr, val))
        if others:
            docs.append("")
            docs.append("*Others*: " + ", ".join(others))

        # Common 4-space indent
        docs = ["    " + doc for doc in docs]

        if cls.__doc__:
            # Get rid of initial new line and any trailing whitespace/newlines
            docs.insert(0, cls.__doc__.lstrip("\n").rstrip())
            docs.insert(1, "    ")

        cls.__doc__ = "\n".join(docs)


class CompState(AutoDocMixin):
    """
    Base class for computed states.

    These are states that are computed strictly from other states and do not
    inject any Transitions.
    """

    def __init_subclass__(cls) -> None:
        """Register the output state keys and the class"""
        for state_key in cls.state_keys:
            if state_key not in STATE_KEYS:
                STATE_KEYS.append(state_key)
            COMP_STATES[state_key] = cls

        cls._auto_update_docstring()


class RaDecRollState(CompState):
    """Compute RA, Dec, and Roll state from quaternion components."""

    state_keys_input = QUAT_COMPS
    state_keys = ["ra", "dec", "roll"]

    @classmethod
    def calc(cls, states: Table) -> dict[str, np.array]:
        q_atts = get_quat_from_state(states)
        return {"ra": q_atts.ra, "dec": q_atts.dec, "roll": q_atts.roll}


class SunAnglesState(CompState):
    """Compute useful state angles related to Sun position and attitude."""

    state_keys_input = QUAT_COMPS + ["sun_vector_update"]
    state_keys = ["pitch", "rasl", "off_nom_roll", "sun_ra", "sun_dec"]

    @classmethod
    def calc(cls, states: Table) -> dict[str, np.array]:
        q_atts = get_quat_from_state(states)
        times_mid = (states["tstart"] + states["tstop"]) / 2

        out = Table(
            np.empty((len(states), 5), dtype=float),
            names=["pitch", "rasl", "off_nom_roll", "sun_ra", "sun_dec"],
        )
        for row, q_att, time_mid in zip(out, q_atts, times_mid):
            sun_ra, sun_dec = ska_sun.position(time_mid)
            row["pitch"], row["rasl"] = ska_sun.get_sun_pitch_yaw(
                ra=q_att.ra, dec=q_att.dec, sun_ra=sun_ra, sun_dec=sun_dec
            )
            row["off_nom_roll"] = ska_sun.off_nominal_roll(
                q_att, sun_ra=sun_ra, sun_dec=sun_dec
            )
            row["sun_ra"] = sun_ra
            row["sun_dec"] = sun_dec

        return {key: out[key] for key in out.colnames}


class BaseTransition(AutoDocMixin):
    """
    Base transition class from which all actual transition classes are subclassed.
    """

    def __init_subclass__(cls) -> None:
        # Register transition classes that have a `state_keys` (base classes do
        # not have this attribute set).
        if hasattr(cls, "state_keys"):
            for state_key in cls.state_keys:
                if state_key not in STATE_KEYS:
                    STATE_KEYS.append(state_key)
                TRANSITIONS[state_key].append(cls)

            TRANSITION_CLASSES.add(cls)

            cls._auto_update_docstring()

    @classmethod
    def get_state_changing_commands(cls, cmds):
        """
        Get commands that match the required attributes for state changing commands.

        This depends on two class attributes that are defined in subclasses:

        ``command_attributes`` (required)
          dict of {cmd_attr: match_value, ..}, where ``cmd_attr`` is either ``type``
          or ``tlmsid``, and ``match_value`` is the required value.

        ``command_params`` (optional)
          dict of {cmd_attr: match_value, ..}, where ``cmd_attr`` is one of the
          available command parameters, and ``match_value`` is either the required value
          or a list of required values (where at least one must match).

        Parameters
        ----------
        cmds : CommandTable
            Input commands

        Returns
        -------
        CommandTable
            Subset of ``cmds`` relevant for this Transition class
        """
        # First filter on command attributes.  These
        ok = np.ones(len(cmds), dtype=bool)
        for attr, val in cls.command_attributes.items():
            ok = ok & (cmds[attr] == val)

        out_cmds = cmds[ok]

        # Second do command_params.  Note could use `cmds[attr] == val`for "vectorized"
        # compare, but unrolling the loop here is more efficient since the CmdList class
        # would internally assemble a pure-Python version of the column first.
        if hasattr(cls, "command_params"):
            attrs_list = list(cls.command_params.keys())
            vals_list = [
                val if isinstance(val, list) else [val]
                for val in cls.command_params.values()
            ]
            ok = np.ones(len(out_cmds), dtype=bool)
            for idx, cmd in enumerate(out_cmds):
                for attr, vals in zip(attrs_list, vals_list):
                    ok_idx = False
                    for val in vals:
                        ok_idx |= cmd[attr] == val
                    ok[idx] = ok[idx] & ok_idx

            out_cmds = out_cmds[ok]

        return out_cmds


class FixedTransition(BaseTransition):
    """
    Transitions for fixed attribute.

    This is for the case of an attribute that gets set to a fixed value when the
    command occurs, e.g. pcad_mode='NMAN' for AONMMODE.

    Class attributes:

    :param transition_key: single transition key or list of transition keys
    :param transition_val: single transition value or list of values
    """

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        vals = cls.transition_val
        attrs = cls.transition_key

        if not isinstance(vals, list):
            vals = [vals]
        if not isinstance(attrs, list):
            attrs = [attrs]

        for cmd in state_cmds:
            transitions_list.append(Transition(cmd["date"], zip(attrs, vals)))  # noqa: PERF401


class ParamTransition(BaseTransition):
    """
    Transitions for case of attribute that gets set to value defined by cmd param.

    E.g. ``obsid`` = ``ID`` parameter of ``COBRQID`` command.

    Class attributes:

    :param transition_key: single transition key or list of transition keys
    :param cmd_param_key: command parameter name (str or list of str)
    """

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        # cmds.rev_pars_dict is either None or a weakref to a dict
        rev_pars_dict = rpd() if (rpd := cmds.rev_pars_dict) else None
        state_cmds = cls.get_state_changing_commands(cmds)
        param_keys = cls.cmd_param_key
        names = cls.transition_key

        if not isinstance(param_keys, list):
            param_keys = [param_keys]
        if not isinstance(names, list):
            names = [names]

        for cmd in state_cmds:
            date = cmd["date"]
            cmd_idx = cmd["idx"]
            if rev_pars_dict is None or cmd_idx == -1:
                params = cmd["params"]
            else:
                params = dict(rev_pars_dict[cmd["idx"]])

            transition = Transition(
                date, zip(names, [params[key] for key in param_keys])
            )
            transitions_list.append(Transition(date, transition))


###################################################################
# CCDM format and subformat transitions
###################################################################


class Format1_Transition(FixedTransition):
    """Transition to telemetry format 1"""

    command_attributes = {"tlmsid": "CSELFMT1"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT1"


class Format2_Transition(FixedTransition):
    """Transition to telemetry format 2"""

    command_attributes = {"tlmsid": "CSELFMT2"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT2"


class Format3_Transition(FixedTransition):
    """Transition to telemetry format 3"""

    command_attributes = {"tlmsid": "CSELFMT3"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT3"


class Format4_Transition(FixedTransition):
    """Transition to telemetry format 4"""

    command_attributes = {"tlmsid": "CSELFMT4"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT4"


class Format5_Transition(FixedTransition):
    """Transition to telemetry format 5"""

    command_attributes = {"tlmsid": "CSELFMT5"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT5"


class Format6_Transition(FixedTransition):
    """Transition to telemetry format 6"""

    command_attributes = {"tlmsid": "CSELFMT6"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT6"


class SubFormatEPS_Transition(FixedTransition):
    """Transition to telemetry EPS subformat"""

    command_attributes = {"tlmsid": "OFMTSEPS"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "EPS"


class SubFormatNRM_Transition(FixedTransition):
    """Transition to telemetry NRM subformat"""

    command_attributes = {"tlmsid": "OFMTSNRM"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "NORM"


class SubFormatPDG_Transition(FixedTransition):
    """Transition to telemetry PDG subformat"""

    command_attributes = {"tlmsid": "OFMTSPDG"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "PDG"


class SubFormatSSR_Transition(FixedTransition):
    """Transition to telemetry SSR subformat"""

    command_attributes = {"tlmsid": "OFMTSSSR"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "SSR"


###################################################################
# Mech transitions
###################################################################


class MechMove(FixedTransition):
    """
    Transitions for mech moves that have non-zero duration.

    This adds two transitions per matched command:
    - First one at cmd time with the transition value with ``_MOVE`` appended
    - Second one at cmd time + move_duration with the straight transition value

    This inherits from FixedTransition for the case of an attribute that gets
    set to a fixed value when the command occurs, e.g. pcad_mode='NMAN' for
    AONMMODE.

    Class attributes:

    :param transition_key: single transition key or list of transition keys
    :param transition_val: single transition value or list of values
    :param move_duration: duration of the move (astropy time Quantity)
    :param apply_move_duration: if True, apply the move duration to states
    """

    apply_move_duration = True

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        vals = cls.transition_val
        attrs = cls.transition_key
        move_duration = cls.move_duration

        if not isinstance(vals, list):
            vals = [vals]
        if not isinstance(attrs, list):
            attrs = [attrs]

        for cmd in state_cmds:
            date_start = CxoTime(cmd["date"])
            date_stop = date_start + move_duration
            transition_start = Transition(date_start.date)
            transition_stop = Transition(date_stop.date)

            for val, attr in zip(vals, attrs):
                if attr == "grating":
                    transition_start[attr] = val
                else:  # noqa: PLR5501
                    # 'letg' or 'hetg' insert/retract status, include the move
                    # interval here
                    if cls.apply_move_duration:
                        transition_start[attr] = val + "_MOVE"
                        transition_stop[attr] = val
                    else:
                        transition_start[attr] = val

            if transition_start:
                transitions_list.append(transition_start)
            if transition_stop:
                transitions_list.append(transition_stop)


class HETG_INSR_Transition(MechMove):
    """HETG insertion"""

    command_attributes = {"tlmsid": "4OHETGIN"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["hetg", "grating"]
    transition_val = ["INSR", "HETG"]
    move_duration = 157 * u.s


class HETG_RETR_Transition(MechMove):
    """HETG retraction"""

    command_attributes = {"tlmsid": "4OHETGRE"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["hetg", "grating"]
    transition_val = ["RETR", "NONE"]
    move_duration = 153 * u.s


class LETG_INSR_Transition(MechMove):
    """LETG insertion"""

    command_attributes = {"tlmsid": "4OLETGIN"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["letg", "grating"]
    transition_val = ["INSR", "LETG"]
    move_duration = 203 * u.s


class LETG_RETR_Transition(MechMove):
    """LETG retraction"""

    command_attributes = {"tlmsid": "4OLETGRE"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["letg", "grating"]
    transition_val = ["RETR", "NONE"]
    move_duration = 203 * u.s


class SimTscTransition(ParamTransition):
    """SIM translating science compartment translation"""

    command_attributes = {"type": "SIMTRANS"}
    state_keys = ["simpos"]
    transition_key = "simpos"
    cmd_param_key = "pos"


class SimFocusTransition(ParamTransition):
    """SIM focus assembly translation"""

    command_attributes = {"type": "SIMFOCUS"}
    state_keys = ["simfa_pos"]
    transition_key = "simfa_pos"
    cmd_param_key = "pos"


###################################################################
# HRC transitions
###################################################################


class Hrc15vOn_Transition(FixedTransition):
    """HRC 15V ON from hardware 215PCAON command"""

    command_attributes = {"tlmsid": "215PCAON"}
    state_keys = ["hrc_15v"]
    transition_key = "hrc_15v"
    transition_val = "ON"


class Hrc15vOn_SCS134_Transition(FixedTransition):
    """HRC 15V ON from SCS-134"""

    command_attributes = {"tlmsid": "COACTSX", "coacts1": 134}
    state_keys = ["hrc_15v"]
    transition_key = "hrc_15v"
    transition_val = "ON"
    default_value = "ON"


class Hrc15vOff_Transition(FixedTransition):
    """HRC 15V OFF"""

    command_attributes = {"tlmsid": "215PCAOF"}
    state_keys = ["hrc_15v"]
    transition_key = "hrc_15v"
    transition_val = "OFF"


class Hrc24vOn_Transition(FixedTransition):
    """HRC 24V ON"""

    command_attributes = {"tlmsid": "224PCAON"}
    state_keys = ["hrc_24v"]
    transition_key = "hrc_24v"
    transition_val = "ON"
    default_value = "ON"


class Hrc24vOff_Transition(FixedTransition):
    """HRC 24V OFF"""

    command_attributes = {"tlmsid": "224PCAOF"}
    state_keys = ["hrc_24v"]
    transition_key = "hrc_24v"
    transition_val = "OFF"


class HrcIOn_Transition(FixedTransition):
    """HRC-I ON"""

    command_attributes = {"tlmsid": "COENASX", "coenas1": 89}
    state_keys = ["hrc_i"]
    transition_key = "hrc_i"
    transition_val = "ON"


class HrcIOff_Transition(FixedTransition):
    """HRC-I OFF"""

    command_attributes = {
        "tlmsid": "2IMHVOF",
    }
    state_keys = ["hrc_i"]
    transition_key = "hrc_i"
    transition_val = "OFF"
    default_value = "OFF"


class HrcSOn_Transition(FixedTransition):
    """HRC-S ON"""

    command_attributes = {"tlmsid": "COENASX", "coenas1": 90}
    state_keys = ["hrc_s"]
    transition_key = "hrc_s"
    transition_val = "ON"


class HrcSOff_Transition(FixedTransition):
    """HRC-S OFF"""

    command_attributes = {
        "tlmsid": "2SPHVOF",
    }
    state_keys = ["hrc_s"]
    transition_key = "hrc_s"
    transition_val = "OFF"
    default_value = "OFF"


###################################################################
# OBC etc transitions
###################################################################


class ObsidTransition(ParamTransition):
    """Obsid update"""

    command_attributes = {"type": "MP_OBSID"}
    state_keys = ["obsid"]
    transition_key = "obsid"
    cmd_param_key = "id"


class EclipseEntryTimerTransition(ParamTransition):
    """Eclipse entry timer update"""

    command_attributes = {"tlmsid": "EOECLETO"}
    state_keys = ["eclipse_timer"]
    transition_key = "eclipse_timer"
    cmd_param_key = "timecnt"


class EclipsePenumbraEntryTransition(FixedTransition):
    """Eclipse penumbra entry"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": ["PENTRY", "LSPENTRY"]}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "PENUMBRA"


class EclipsePenumbraExitTransition(FixedTransition):
    """Eclipse penumbra exit"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": ["PEXIT", "LSPEXIT"]}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "DAY"


class EclipseUmbraEntryTransition(FixedTransition):
    """Eclipse umbra entry"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": "EONIGHT"}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "UMBRA"


class EclipseUmbraExitTransition(FixedTransition):
    """Eclipse umbra exit"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": "EODAY"}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "PENUMBRA"


class SPMEnableTransition(FixedTransition):
    """Sun position monitor enable"""

    command_attributes = {"tlmsid": "AOFUNCEN"}
    command_params = {"aopcadse": 30}
    state_keys = SPM_STATE_KEYS
    transition_key = "sun_pos_mon"
    transition_val = "ENAB"


class SPMDisableTransition(FixedTransition):
    """Sun position monitor disable"""

    command_attributes = {"tlmsid": "AOFUNCDS"}
    command_params = {"aopcadsd": 30}
    state_keys = SPM_STATE_KEYS
    transition_key = "sun_pos_mon"
    transition_val = "DISA"


class SPMEclipseEnableTransition(BaseTransition):
    """
    Automatic enable of sun position monitor.

    This occurs 11 minutes after eclipse exit, but only if the battery-connect
    command occurs within 135 seconds of eclipse entry.

    Connect batteries is an event type COMMAND_SW and TLMSID= EOESTECN
    Eclipse entry is event type ORBPOINT with TYPE=PENTRY or TYPE=LSPENTRY
    Eclipse exit is event type ORBPOINT with TYPE=PEXIT or TYPE=LSPEXIT
    """

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": ["PEXIT", "LSPEXIT"]}
    state_keys = SPM_STATE_KEYS
    default_value = False

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        # Preselect only commands that might have an impact here.
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transitions_list.append(  # noqa: PERF401
                Transition(cmd["date"], sun_pos_mon=TransitionCallback(cls.callback))
            )

    @classmethod
    def callback(cls, date, transitions, state, idx):
        if state["eclipse_enable_spm"]:
            transition = Transition(
                secs2date(date2secs(date) + 11 * 60), {"sun_pos_mon": "ENAB"}
            )
            add_transition(transitions, idx, transition)


class EclipseEnableSPM(BaseTransition):
    """Flag to indicate whether SPM will be enabled 11 minutes after eclipse exit.

    This is evaluated at the time of eclipse entry and checks that the most recent
    battery connect command (via the ``battery_connect`` state) was within 135 seconds
    of eclipse entry.

    See email thread "Criteria for SPM auto-enable following eclipse" around 2024-Feb-17
    for more details on the 135 second threshold.
    """

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": ["PENTRY", "LSPENTRY"]}
    state_keys = SPM_STATE_KEYS
    default_value = False

    BATTERY_CONNECT_MAX_DT = 135  # seconds

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        # Preselect only commands that might have an impact here.
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transitions_list.append(  # noqa: PERF401
                Transition(
                    cmd["date"], eclipse_enable_spm=TransitionCallback(cls.callback)
                )
            )

    @classmethod
    def callback(cls, date, transitions, state, idx):
        """Set flag if SPM will be enabled 11 minutes after eclipse exit.

        ``battery_connect`` is the time of the battery connect EOESTECN command,
        which must occur prior to this command which is eclipse entry.
        """
        if state["battery_connect"] is None:
            return

        battery_connect_time = date2secs(state["battery_connect"])
        eclipse_entry_time = date2secs(date)
        # By definition, the battery connect time is always less than the eclipse entry.
        enable_spm = (
            eclipse_entry_time - battery_connect_time < cls.BATTERY_CONNECT_MAX_DT
        )
        transition = Transition(date, eclipse_enable_spm=enable_spm)
        add_transition(transitions, idx, transition)


class BatteryConnect(BaseTransition):
    """Most recent battery connect time (type=COMMAND_SW and tlmsid=EOESTECN)"""

    command_attributes = {"tlmsid": "EOESTECN"}
    state_keys = SPM_STATE_KEYS

    default_value = "1999:001:00:00:00.000"

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transitions_list.append(  # noqa: PERF401
                Transition(cmd["date"], battery_connect=cmd["date"])
            )


class SCS84EnableTransition(FixedTransition):
    """SCS-84 enable"""

    command_attributes = {"tlmsid": "COENASX"}
    command_params = {"coenas1": 84}
    state_keys = ["scs84"]
    transition_key = "scs84"
    transition_val = "ENAB"
    default_value = "DISA"


class SCS84DisableTransition(FixedTransition):
    """SCS-84 disable"""

    command_attributes = {"tlmsid": "CODISASX"}
    command_params = {"codisas1": 84}
    state_keys = ["scs84"]
    transition_key = "scs84"
    transition_val = "DISA"


class SCS98EnableTransition(FixedTransition):
    """SCS-98 enable"""

    command_attributes = {"tlmsid": "COENASX"}
    command_params = {"coenas1": 98}
    state_keys = ["scs98"]
    transition_key = "scs98"
    transition_val = "ENAB"


class SCS98DisableTransition(FixedTransition):
    """SCS-98 disable"""

    command_attributes = {"tlmsid": "CODISASX"}
    command_params = {"codisas1": 98}
    state_keys = ["scs98"]
    transition_key = "scs98"
    transition_val = "DISA"


class RadmonEnableTransition(FixedTransition):
    """RADMON enable"""

    command_attributes = {"tlmsid": "OORMPEN"}
    state_keys = ["radmon"]
    transition_key = "radmon"
    transition_val = "ENAB"


class RadmonDisableTransition(FixedTransition):
    """RADMON disable"""

    command_attributes = {"tlmsid": "OORMPDS"}
    state_keys = ["radmon"]
    transition_key = "radmon"
    transition_val = "DISA"


class OrbitPointTransition(ParamTransition):
    """Orbit point state based on backstop ephemeris entries"""

    command_attributes = {"type": "ORBPOINT"}
    state_keys = ["orbit_point"]
    transition_key = "orbit_point"
    cmd_param_key = "event_type"


class EphemerisTransition(ParamTransition):
    """On-board ephemeris update values"""

    command_attributes = {"tlmsid": "AOEPHUPS"}
    state_keys = [
        "aoephem1",
        "aoephem2",
        "aoratio",
        "aoargper",
        "aoeccent",
        "ao1minus",
        "ao1plus",
        "aomotion",
        "aoiterat",
        "aoorbang",
        "aoperige",
        "aoascend",
        "aosini",
        "aoslr",
        "aosqrtmu",
    ]
    transition_key = state_keys
    cmd_param_key = state_keys


class EphemerisUpdateTransition(BaseTransition):
    """
    On-board ephemeris update date.

    Mostly useful for the FOT to assist in backstop processing.
    """

    command_attributes = {"tlmsid": "AOEPHUPS"}
    state_keys = ["ephem_update"]

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            date = cmd["date"]
            transitions_list.append(Transition(date, ephem_update=date[:8]))


###################################################################


class SunVectorTransition(BaseTransition):
    """
    Add transitions between start/stop every 10 ksec.

    This is to sample the pitch and off_nominal roll during NPNT.  These are
    function transitions which check to see that ``pcad_mode == 'NPNT'`` before
    changing the pitch / off_nominal_roll.
    """

    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        # np.ceil is used here to get 'times' between start/stop at even
        # increments of "sample_time" so that the commands will be at the same
        # times in an interval even if a different time range is being updated.
        sample_time = 10000
        tstart = np.ceil(DateTime(start).secs / sample_time) * sample_time
        tstop = DateTime(stop).secs
        times = np.arange(tstart, tstop, sample_time)
        dates = DateTime(times).date

        # Now with the dates, finally make all the transition dicts which will
        # call `update_pitch_state` during state processing.
        for date in dates:
            transitions_list.append(  # noqa: PERF401
                Transition(
                    date,
                    update_sun_vector=TransitionCallback(cls.update_sun_vector_state),
                )
            )

    @classmethod
    def update_sun_vector_state(cls, date, transitions, state, idx):
        """
        Transition callback method for ``sun_ra``, ``sun_dec`` states.

        Parameters
        ----------
        date
            date (str)
        transitions
            global list of transitions
        state
            current state (dict)
        idx
            current index into transitions
        """
        if state["pcad_mode"] == "NPNT":
            state["sun_vector_update"] = 0


class DitherEnableTransition(FixedTransition):
    """Dither enable"""

    command_attributes = {"tlmsid": "AOENDITH"}
    state_keys = ["dither"]
    transition_key = "dither"
    transition_val = "ENAB"


class DitherDisableTransition(FixedTransition):
    """Dither disable"""

    command_attributes = {"tlmsid": "AODSDITH"}
    state_keys = ["dither"]
    transition_key = "dither"
    transition_val = "DISA"


class DitherParamsTransition(BaseTransition):
    """Dither parameters"""

    command_attributes = {"tlmsid": "AODITPAR"}
    state_keys = [
        "dither_phase_pitch",
        "dither_phase_yaw",
        "dither_ampl_pitch",
        "dither_ampl_yaw",
        "dither_period_pitch",
        "dither_period_yaw",
    ]

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            dither = {
                "dither_phase_pitch": np.degrees(cmd["angp"]),
                "dither_phase_yaw": np.degrees(cmd["angy"]),
                "dither_ampl_pitch": np.degrees(cmd["coefp"]) * 3600,
                "dither_ampl_yaw": np.degrees(cmd["coefy"]) * 3600,
                "dither_period_pitch": 2 * np.pi / cmd["ratep"],
                "dither_period_yaw": 2 * np.pi / cmd["ratey"],
            }
            transitions_list.append(Transition(cmd["date"], dither))


class NMM_Transition(FixedTransition):
    """Transition to Normal Maneuver Mode"""

    command_attributes = {"tlmsid": "AONMMODE"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "pcad_mode"
    transition_val = "NMAN"


class NPM_Transition(FixedTransition):
    """Transition to Normal Point Mode"""

    command_attributes = {"tlmsid": "AONPMODE"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "pcad_mode"
    transition_val = "NPNT"


class AutoNPMEnableTransition(FixedTransition):
    """Enable automatic transition to Normal Point Mode"""

    command_attributes = {"tlmsid": "AONM2NPE"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "auto_npnt"
    transition_val = "ENAB"


class AutoNPMDisableTransition(FixedTransition):
    """Disable automatic transition to Normal Point Mode"""

    command_attributes = {"tlmsid": "AONM2NPD"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "auto_npnt"
    transition_val = "DISA"


class TargQuatTransition(BaseTransition):
    """Commanded target quaternion"""

    command_attributes = {"type": "MP_TARGQUAT"}
    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transition = Transition(
                cmd["date"], {f"targ_{qc}": cmd[qc] for qc in QUAT_COMPS}
            )
            transitions_list.append(transition)


class ManeuverTransition(BaseTransition):
    """
    Execute maneuver.

    This is a relatively complex transition that computes the intermediate
    quaternion values for the maneuver and inserts downstream transitions to
    perform attitude quaternion updated accordingly.  At the end of the maneuver
    it schedules a NPM transition if ``auto_npnt`` is enabled.
    """

    command_attributes = {"tlmsid": "AOMANUVR"}
    state_keys = PCAD_STATE_KEYS
    pcad_mode = "NMAN"

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transitions_list.append(  # noqa: PERF401
                Transition(
                    cmd["date"], maneuver_transition=TransitionCallback(cls.callback)
                )
            )

    @classmethod
    def callback(cls, date, transitions, state, idx):
        """
        Transition function callback to generate downstream transitions.

        These perform the actual maneuver and (usually) transition to NPM at the
        end of maneuver.
        """
        end_manvr_date = cls.add_manvr_transitions(date, transitions, state, idx)

        # If no target attitude has been defined to this point then we cannot
        # do state processing for a maneuver, so drop it on the floor.
        if end_manvr_date is None:
            return

        # If auto-transition to NPM after manvr is enabled (this is normally the case)
        # then back to NPNT at end of maneuver
        if state["auto_npnt"] == "ENAB":
            # Auto-transition to NPNT only works from NMAN. The lambda constraint will
            # prevent transition to NPNT if NSM or Safe mode transition occurs during
            # maneuver.
            transition = Transition(
                end_manvr_date,
                lambda state_: state_["pcad_mode"] == "NMAN",
                pcad_mode="NPNT",
            )
            add_transition(transitions, idx, transition)

    @classmethod
    def add_manvr_transitions(cls, date, transitions, state, idx):
        """
        This does the main work of adding transitions for a maneuver.

        It is called by the ManeuverTransition and NormalSunTransition classes.
        """
        # Get the current target attitude state
        targ_att = [state["targ_" + qc] for qc in QUAT_COMPS]

        # Check that target attitude is defined. If start time is between
        # AOUPTARQ and AOMANUVR command then this will happen. In this case just
        # drop the maneuver on the floor, consistent with attitude state being
        # undefined.
        if None in targ_att:
            return None

        # Deal with startup transient where spacecraft attitude is not known.
        # In this case first maneuver is a bogus null maneuver.
        if state["q1"] is None:
            for qc in QUAT_COMPS:
                state[qc] = state["targ_" + qc]

        # Get current spacecraft attitude
        curr_att = [state[qc] for qc in QUAT_COMPS]

        # Get attitudes for maneuver at about 2.5-minute intervals. Even-indexed (2N)
        # attitudes are for the transition times (state start) and the odd-indexed
        # (2N+1) attitudes are used for the attitude values. This means that the
        # attitude states reflect the attitude at the midpoint of the maneuver states.
        atts = chandra_maneuver.attitudes(
            curr_att,
            targ_att,
            tstart=date2secs(date),
            step=150,
        )
        # Make sure there are an even number of attitudes so that we always have a final
        # 2N+1 index. Repeat the final attitude if necessary.
        if (n_att := len(atts)) % 2 == 1:
            atts = np.concatenate([atts, atts[n_att - 1 :]])

        # Add transitions for each bit of the maneuver.  Note that this sets the
        # attitude (q1..q4) at the *midpoint* of each state.
        for time, att_mid in zip(atts["time"][::2], atts[1::2], strict=True):
            # Check pcad_mode at time of each maneuver transition is same as at start.
            # This cuts off maneuver for a mode change like NSM or Safe mode. Note that
            # `state_` is the future state and `state` is the current state.
            date_att = secs2date(time)
            transition = Transition(
                date_att, lambda state_: state_["pcad_mode"] == state["pcad_mode"]
            )
            for qc in QUAT_COMPS:
                transition[qc] = att_mid[qc]

            add_transition(transitions, idx, transition)

        return secs2date(atts["time"][-1])  # Date of end of maneuver.


class NormalSunTransition(ManeuverTransition):
    """
    Same as ``ManeuverTransition`` except perform maneuver to NSM.

    This uses ska_sun.get_nsm_attitude() to get the NSM attitude, potentially at
    an offset pitch like 160 degrees.  It also changes ``pcad_mode`` to NSUN.
    """

    command_attributes = {"tlmsid": "AONSMSAF"}
    pcad_mode = "NSUN"
    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        state_cmds = cls.get_state_changing_commands(cmds)

        # Set the maneuver transition for each state-changing command. The AONSMSAF or
        # ACPCSFSU commands have an optional pitch parameter corresponding to the Params
        # value of the params for the NSM or Safe Mode command events. If not provided
        # then use 90 degrees.

        for cmd in state_cmds:
            pitch = cmd["params"].get("pitch", 90)
            transitions_list.append(
                Transition(
                    cmd["date"],
                    maneuver_transition=TransitionCallback(
                        cls.callback, {"pitch": pitch}
                    ),
                )
            )

    @classmethod
    def callback(cls, date, transitions, state, idx, *, pitch):
        """
        This is a transition function callback.

        It sets the state pcad_mode to ``cls.pcad_mode`` and target quaternion to
        the expected sun pointed attitude.  It then calls the parent method to
        add the actual maneuver.
        """
        # Transition to appropriate PCAD mode
        state["pcad_mode"] = cls.pcad_mode

        # Setup for maneuver to sun-pointed attitude from current att
        curr_att = [state[qc] for qc in QUAT_COMPS]

        # If current attitude is not defined then just drop the NSM maneuver on
        # the floor. The state will start getting defined when the first normal
        # maneuver happens.
        if None in curr_att:
            return

        targ_att = ska_sun.get_nsm_attitude(curr_att, date, pitch)
        for qc, targ_q in zip(QUAT_COMPS, targ_att.q):
            state["targ_" + qc] = targ_q

        # Do the maneuver
        cls.add_manvr_transitions(date, transitions, state, idx)


class SafeSunTransition(NormalSunTransition):
    """
    Similar to ``NormalSunTransition`` but in Safe Sun Mode with pcad_mode = STBY.

    This uses ska_sun.get_nsm_attitude() to get the NSM attitude, potentially at
    an offset pitch like 160 degrees.  It also changes ``pcad_mode`` to STBY.
    """

    command_attributes = {"tlmsid": "ACPCSFSU"}
    pcad_mode = "STBY"
    state_keys = PCAD_STATE_KEYS


class ManeuverSunPitchTransition(ManeuverTransition):
    """
    Like ``ManeuverTransition`` except perform a pure-pitch maneuver from attitude.

    This does not change the PCAD mode.
    """

    command_attributes = {"type": "LOAD_EVENT", "tlmsid": "SUN_PITCH"}
    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transitions_list.append(  # noqa: PERF401
                Transition(
                    cmd["date"],
                    maneuver_transition=TransitionCallback(
                        cls.callback, {"pitch": cmd["params"]["pitch"]}
                    ),
                )
            )

    @classmethod
    def callback(cls, date, transitions, state, idx, *, pitch):
        # Setup for maneuver to sun-pointed attitude from current att
        curr_att = [state[qc] for qc in QUAT_COMPS]

        # If current attitude is not defined then just drop the NSM maneuver on
        # the floor. The state will start getting defined when the first normal
        # maneuver happens.
        if None in curr_att:
            return

        curr_att = Quat(curr_att)
        sun_ra, sun_dec = ska_sun.position(date)
        curr_pitch = ska_sun.pitch(
            curr_att.ra, curr_att.dec, sun_ra=sun_ra, sun_dec=sun_dec
        )
        targ_att = ska_sun.apply_sun_pitch_yaw(
            curr_att, pitch=pitch - curr_pitch, yaw=0, sun_ra=sun_ra, sun_dec=sun_dec
        )
        for qc, targ_q in zip(QUAT_COMPS, targ_att.q):
            state["targ_" + qc] = targ_q

        # Do the maneuver
        ManeuverTransition.add_manvr_transitions(date, transitions, state, idx)


class ManeuverSunRaslTransition(ManeuverTransition):
    """
    Like ``ManeuverTransition`` except roll about the sun line.

    This does not change the PCAD mode.
    """

    command_attributes = {"type": "LOAD_EVENT", "tlmsid": "SUN_RASL"}
    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transitions_list.append(  # noqa: PERF401
                Transition(
                    cmd["date"],
                    maneuver_transition=TransitionCallback(
                        cls.callback, {"rasl": cmd["params"]["rasl"]}
                    ),
                )
            )

    @classmethod
    def callback(cls, date, transitions, state, idx, *, rasl):
        # Setup for maneuver to sun-pointed attitude from current att
        curr_att = [state[qc] for qc in QUAT_COMPS]

        # If current attitude is not defined then just drop the NSM maneuver on
        # the floor. The state will start getting defined when the first normal
        # maneuver happens.
        if None in curr_att:
            return

        curr_att = Quat(curr_att)
        sun_ra, sun_dec = ska_sun.position(date)
        targ_att = ska_sun.apply_sun_pitch_yaw(
            curr_att, yaw=rasl, sun_ra=sun_ra, sun_dec=sun_dec
        )
        for qc, targ_q in zip(QUAT_COMPS, targ_att.q):
            state["targ_" + qc] = targ_q

        # Do the maneuver
        ManeuverTransition.add_manvr_transitions(date, transitions, state, idx)


###################################################################
# ACIS transitions
###################################################################
def decode_power(mnem):
    """
    Decode number of chips and feps from a ACIS power command.

    Return a dictionary with the number of chips and their identifiers

    Example::

        >>> decode_power("WSPOW08F3E")
        {'ccd_count': 5,
        'ccds': 'I0 I1 I2 I3 S3 ',
        'clocking': 0,
        'fep_count': 5,
        'feps': '1 2 3 4 5 ',
        'vid_board': 1}

    Parameters
    ----------
    mnem
        power command string
    """
    fep_info = {
        "fep_count": 0,
        "ccd_count": 0,
        "feps": "",
        "ccds": "",
        "vid_board": 1,
        "clocking": 0,
    }

    # Special case WSPOW000XX to turn off vid_board
    if mnem.startswith("WSPOW000"):
        fep_info["vid_board"] = 0

    # the hex for the commanding is after the WSPOW
    powstr = mnem[5:]
    if len(powstr) != 5:
        raise ValueError("%s in unexpected format" % mnem)

    # convert the hex to decimal and "&" it with 63 (binary 111111)
    fepkey = int(powstr, 16) & 63
    # count the true binary bits
    for bit in range(6):
        if fepkey & (1 << bit):
            fep_info["fep_count"] = fep_info["fep_count"] + 1
            fep_info["feps"] = fep_info["feps"] + str(bit) + " "

    # convert the hex to decimal and right shift by 8 places
    vidkey = int(powstr, 16) >> 8

    # count the true bits
    for bit in range(10):
        if vidkey & (1 << bit):
            fep_info["ccd_count"] = fep_info["ccd_count"] + 1
            # position indicates I or S chip
            if bit < 4:
                fep_info["ccds"] = fep_info["ccds"] + "I" + str(bit) + " "
            else:
                fep_info["ccds"] = fep_info["ccds"] + "S" + str(bit - 4) + " "

    return fep_info


class ACISTransition(BaseTransition):
    """
    Implement transitions for ACIS states.
    """

    command_attributes = {"type": "ACISPKT"}
    state_keys = [
        "clocking",
        "power_cmd",
        "vid_board",
        "fep_count",
        "si_mode",
        "ccd_count",
        "obsid",
        "feps",
        "ccds",
    ]

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        for cmd in state_cmds:
            tlmsid = cmd["tlmsid"]
            date = cmd["date"]
            transition = Transition(date)

            if tlmsid.startswith("WSPOW"):
                pwr = decode_power(tlmsid)
                transition.update(
                    fep_count=pwr["fep_count"],
                    ccd_count=pwr["ccd_count"],
                    feps=pwr["feps"],
                    ccds=pwr["ccds"],
                    vid_board=pwr["vid_board"],
                    clocking=pwr["clocking"],
                    power_cmd=tlmsid,
                )

            elif tlmsid in ("XCZ0000005", "XTZ0000005"):
                transition.update(clocking=1, power_cmd=tlmsid)

            elif tlmsid == "WSVIDALLDN":
                transition.update(vid_board=0, ccd_count=0, ccds="", power_cmd=tlmsid)

            elif tlmsid == "AA00000000":
                transition.update(clocking=0, power_cmd=tlmsid)

            elif tlmsid == "WSFEPALLUP":
                transition.update(fep_count=6, feps="0 1 2 3 4 5 ", power_cmd=tlmsid)

            elif tlmsid[:2] in ("WT", "WC"):
                transition["si_mode"] = TransitionCallback(
                    cls.simode_callback, {"tlmsid": tlmsid}
                )

            transitions_list.append(transition)

    @classmethod
    def simode_callback(cls, date, transitions, state, idx, *, tlmsid):
        # Other SIMODEs than the ones caught here exist in the
        # ACIS tables, and may be used in execptional circumstances
        # such as anomalies or special tests. The ones that are
        # listed here are commonly used in schedules.

        # Two special-case raw-mode SI modes
        # (https://github.com/sot/cmd_states/issues/23)
        if tlmsid == "WT000B5024":
            si_mode = "TN_000B4"

        elif tlmsid == "WT000B7024":
            si_mode = "TN_000B6"

        # Special case for NIL SI modes
        elif tlmsid in NIL_SIMODES:
            # Ensure that the obsid is set. When evaluating continuity the code can get
            # to this point with obsid=None. Instead do nothing here and let obsid get
            # defined and the code will come back here with a longer lookback.
            if state["obsid"] is None:
                return

            si_mode = NIL_SIMODES[tlmsid]
            # Value of SIMODE in some cases depends on whether obsid is
            # an odd or even number
            if si_mode.startswith("HIE") and state["obsid"] % 2 != 0:
                si_mode = si_mode.replace("HIE", "HIO")

        # All other SI modes: this logic uses the PBLK command to
        # determine the SI mode hex string, which depends in part on
        # whether a bias is being (re)computed.
        elif tlmsid[:2] in ("WT", "WC"):
            mode = {"WT": "TE", "WC": "CC"}[tlmsid[:2]]
            # find the hex digits in the PBLK command
            digits = int(tlmsid[2:7], 16)
            if digits % 2 != 0:
                # A bias is not being computed
                digits -= 1
                end = ""
            else:
                # A bias is being computed
                end = "B"
            si_mode = f"{mode}_{digits:05X}{end}"

        else:
            # We have ended up with an SIMODE that is not typical,
            # potentially due to an anomaly or a test. We simply
            # set "undef" here.
            si_mode = "undef"

        state["si_mode"] = si_mode


class ACISFP_SetPointTransition(BaseTransition):
    """
    Implement transitions for ACIS focal plane temperature setpoint state.

    Looks for ACISPKT commands with TLMSID like ``WSFTNEG<number>``, where the
    ACIS FP setpoint temperature is ``-<number>``.
    """

    command_attributes = {"type": "ACISPKT"}
    state_keys = ["acisfp_setpoint"]
    default_value = -121.0

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        for cmd in state_cmds:
            tlmsid = cmd["tlmsid"]
            date = cmd["date"]

            if tlmsid.startswith("WSFTNEG"):
                match = re.search(r"(\d+)$", tlmsid)
                if not match:
                    raise ValueError(f"unable to parse command {tlmsid}")
                transitions_list.append(
                    Transition(date, acisfp_setpoint=-float(match.group(1)))
                )


class FidsTransition(BaseTransition):
    """
    Fid light transitions.

    This sets the "fids" to a Python set of FID IDs that are currently on.

    The relevant fid light commands are shown below. Basically it comes down to AFLCxxDy
    (fid id xx and driver y) commands, AFLCRSET and AFLCAAOF/AFLCAAON/AFLCABOF/AFLCABON
    commands. The latter four are never used (we don't turn the fid light controllers on
    or off in loads). This table is from the CDB in
    ``$SKA/data/Ska.tdb/cdb/p010/cdb_command.csv``.
    ::

        cmd_mnemonic                 technical_name
        ------------ ---------------------------------------------
            AFLC01D1   drive flca fid light 1 (acis-1) on driver 1
            AFLC01D2   drive flca fid light 1 (acis-1) on driver 2
            AFLC01D3   drive flca fid light 1 (acis-1) on driver 3
            AFLC01D4   drive flca fid light 1 (acis-1) on driver 4
            AFLC02D1   drive flca fid light 2 (acis-2) on driver 1
            AFLC02D2   drive flca fid light 2 (acis-2) on driver 2
            AFLC02D3   drive flca fid light 2 (acis-2) on driver 3
            AFLC02D4   drive flca fid light 2 (acis-2) on driver 4
            AFLC03D1   drive flca fid light 3 (acis-3) on driver 1
            AFLC03D2   drive flca fid light 3 (acis-3) on driver 2
            AFLC03D3   drive flca fid light 3 (acis-3) on driver 3
            AFLC03D4   drive flca fid light 3 (acis-3) on driver 4
            AFLC04D1   drive flca fid light 4 (acis-4) on driver 1
            AFLC04D2   drive flca fid light 4 (acis-4) on driver 2
            AFLC04D3   drive flca fid light 4 (acis-4) on driver 3
            AFLC04D4   drive flca fid light 4 (acis-4) on driver 4
            AFLC05D1   drive flca fid light 5 (acis-5) on driver 1
            AFLC05D2   drive flca fid light 5 (acis-5) on driver 2
            AFLC05D3   drive flca fid light 5 (acis-5) on driver 3
            AFLC05D4   drive flca fid light 5 (acis-5) on driver 4
            AFLC06D1   drive flca fid light 6 (acis-6) on driver 1
            AFLC06D2   drive flca fid light 6 (acis-6) on driver 2
            AFLC06D3   drive flca fid light 6 (acis-6) on driver 3
            AFLC06D4   drive flca fid light 6 (acis-6) on driver 4
            AFLC07D1  drive flca fid light 7 (hrc-i-1) on driver 1
            AFLC08D2  drive flca fid light 8 (hrc-i-2) on driver 2
            AFLC09D3  drive flca fid light 9 (hrc-i-3) on driver 3
            AFLC10D4 drive flca fid light 10 (hrc-i-4) on driver 4
            AFLC11D1 drive flca fid light 11 (hrc-s-1) on driver 1
            AFLC12D2 drive flca fid light 12 (hrc-s-3) on driver 2
            AFLC13D3 drive flca fid light 13 (hrc-s-2) on driver 3
            AFLC14D4 drive flca fid light 14 (hrc-s-4) on driver 4
            AFLCAAOF                                  flca - a off
            AFLCAAON                                   flca - a on
            AFLCABOF                                  flca - b off
            AFLCABON                                   flca - b on
            AFLCRSET                      flca configuration reset
    """

    command_attributes = {"tlmsid": "AFIDP"}
    state_keys = ["fids"]

    @classmethod
    def set_transitions(cls, transitions_list: list[Transition], cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        Parameters
        ----------
        transitions_list
            list of transitions (updated in-place)
        cmds
            commands (CmdList)
        start
            start time for states
        stop
            stop time for states

        Returns
        -------
        None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            msid = cmd["msid"]
            if msid == "AFLCRSET" or re.match(r"AFLC \d\d D \d $", msid, re.VERBOSE):
                transitions_list.append(
                    Transition(
                        cmd["date"],
                        fids=TransitionCallback(cls.fids_callback, {"msid": msid}),
                    )
                )

    @classmethod
    def fids_callback(cls, date, transitions, state, idx, *, msid):
        """Update ``state`` for the given fid light command ``msid``."""
        if msid == "AFLCRSET":
            state["fids"] = set()
        else:
            # Only AFLCxxDy commands can make it here from set_transitions filtering
            fid_id = int(msid[4:6])
            # state["fids"] could be None at the beginning so wait until an AFLCRSET
            # command to define it.
            if state["fids"] is None:
                return
            # Add the fid light to the ON set
            state["fids"] = state["fids"] | {fid_id}


###################################################################
# State transitions processing code
###################################################################


def get_quat_from_state(state: dict | Table | TableRow) -> Quat:
    """
    Get the quaternion from the state.

    Parameters
    ----------
    state
        state dictionary or Table or Table Row with q1..q4 keys

    Returns
    -------
    Quat
    """
    q = np.array([state[comp] for comp in QUAT_COMPS]).transpose()
    return Quat(q=q)


def get_transition_classes(state_keys=None):
    """
    Get BaseTransition subclasses in module for ``state_keys``.
    """
    if isinstance(state_keys, str):
        state_keys = [state_keys]
    elif state_keys is None:
        state_keys = DEFAULT_STATE_KEYS

    trans_classes = set(
        itertools.chain.from_iterable(
            classes
            for state_key, classes in TRANSITIONS.items()
            if state_key in state_keys
        )
    )

    return trans_classes


def get_transitions_list(
    cmds, state_keys, start, stop, continuity=None
) -> list[Transition]:
    """
    Get transitions for given set of ``cmds`` and ``state_keys``.

    A ``transition`` here defines a state transition.  It is a dict with a
    ``date`` key (date of transition) and key/value pairs corresponding to the
    state keys that change.

    If ``state_keys`` is None then all known state keys are included.

    Parameters
    ----------
    cmds
        CmdList with spacecraft commands
    state_keys
        desired state keys (None, str, or list)

    Returns
    -------
    list of dict (transitions), set of transition classes
    """
    # To start, collect a list transitions of dated transitions.
    transitions_list: list[Transition] = []

    # If an initial list of transitions is provided in the continuity dict
    # then apply those.  These would be transitions that occur after the the
    # continuity time, e.g. in the case continuity in the middle of a maneuver
    # where we need the remaining attitude and pcad_mode transitions.
    if continuity is not None and "__transitions__" in continuity:
        for transition in continuity["__transitions__"]:
            transitions_list.append(transition)

    # Iterate through Transition classes which depend on or affect ``state_keys``
    # and ask each one to update ``transitions_list`` in-place to include
    # transitions from that class.
    for transition_class in get_transition_classes(state_keys):
        transition_class.set_transitions(transitions_list, cmds, start, stop)

    # Convert the dict of transitions (keyed by date) into an ordered list of
    # transitions sorted by date.  A *list* of transitions is needed to allow a
    # transition to dynamically generate additional (later) transitions, e.g. in
    # the case of a maneuver.
    transitions_list = sorted(transitions_list, key=lambda x: x.date)

    # In the rest of this module ``transitions`` is always this *list* of transitions.
    return transitions_list


def add_transition(transitions: list[Transition], idx: int, transition: Transition):
    """
    Add ``transition`` to the ``transitions`` list.

    This is done at the first appropriate place after the ``idx`` entry.

    This is typically used by dynamic transitions that are actually calling a
    function to generate downstream transitions.  The ManeuverTransition class
    is the canonical example.

    Parameters
    ----------
    transitions
        global list of transition dicts
    idx
        current index into transitions in state processing
    transition
        transition to add (dict)

    Returns
    -------
    None
    """
    # Prevent adding command before current command since the command
    # interpreter is a one-pass process.
    date = transition.date
    if date < transitions[idx].date:
        raise ValueError("cannot insert transition prior to current command")

    # Insert transition at first place where new transition date is strictly
    # less than existing transition date.  This implementation is linear, and
    # could be improved, though in practice transitions are often inserted
    # close to the original.
    for ii in range(idx + 1, len(transitions)):
        if date < transitions[ii].date:
            transitions.insert(ii, transition)
            break
    else:
        transitions.append(transition)


def get_states(
    start=None,
    stop=None,
    state_keys=None,
    cmds=None,
    continuity=None,
    reduce=True,
    merge_identical=False,
    scenario=None,
    event_filter=None,
) -> Table:
    """
    Get table of states for intervals when ``state_keys`` params are unchanged.

    If ``state_keys`` is ``None`` then the default keys
    ``states.DEFAULT_STATE_KEYS`` is used.  This corresponds to the "classic"
    Chandra commanded states (obsid, ACIS, PCAD, and mechanisms).  One can also
    provide a single state key as a a string, e.g. ``state_keys='obsid'``.

    If the ``cmds`` argument is not provided then the ``start`` and ``stop`` are
    used to fetch the commands internally. If the ``stop`` date is not provided
    then all known commands (including future commands from approved loads) will
    be included.

    The output table will contain columns for ``state_keys`` along with
    ``datestart`` and ``datestop`` columns.  By default the ``reduce_states``
    function is called (with the supplied value of ``merge_identical``) in order
    to reduce down to the specified ``state_keys``.

    If ``reduce`` is ``False`` then ``reduce_states`` is not called and output
    table may include additional columns for related states.  For instance in
    order to compute the attitude quaternion state ``q1`` it is necessary to
    collect a number of other states such as ``pcad_mode`` and target
    quaternions ``targ_q1`` through ``targ_q4``.  One can call the
    ``reduce_states()`` function separately to reduce to only the desired state
    keys.

    Parameters
    ----------
    start : CxoTime-like, optional
        Start of states (default is 1999:001).
    stop : CxoTime-like, optional
        Stop of states (default is current time + 1 year).
    state_keys : list of str, optional
        State keys of interest.
    cmds : CmdList, CommandTable, optional
        Input commands.
    continuity : dict, optional
        Initial state.
    reduce : bool, optional
        Call reduce_states() on output (default=True).
    merge_identical : bool, optional
        Merge identical states (see reduce_states() docs, default=False).
    scenario : str, optional
        Name of commands archive scenario to use instead of default.
    event_filter : callable, list of callable, None
        Callable function or list of callable functions that takes an Event Table as
        input and returns a boolean mask with same length as Table. This is used to
        select rows from the Table. If None, no filtering is done.

    Returns
    -------
    astropy Table of states
    """
    # Define complete list of column names for output table corresponding to
    # each state key.  Maintain original order and uniqueness of keys.
    if state_keys is None:
        state_keys = DEFAULT_STATE_KEYS
    elif isinstance(state_keys, str):
        state_keys = [state_keys]

    # Get the full set of state keys that are associated with the requested state keys.
    state_keys_all = get_associated_state_keys(state_keys)

    # Get commands, either from `cmds` arg or from `start` / `stop`
    if cmds is None:
        if start is None:
            raise ValueError("must supply either 'cmds' argument or 'start' argument")
        cmds = commands.get_cmds(
            start, stop, scenario=scenario, event_filter=event_filter
        )
        start = DateTime(start).date
        stop = DateTime(
            stop or cmds[-1]["date"]
        ).date  # User-supplied stop or last command
    else:
        start = cmds[0]["date"] if start is None else DateTime(start).date
        stop = cmds[-1]["date"] if stop is None else DateTime(stop).date

    # Get initial state at start of commands
    if continuity is None:
        try:
            continuity = get_continuity(
                start, state_keys_all, scenario=scenario, event_filter=event_filter
            )
        except ValueError as exc:
            if "did not find transitions" in str(exc):
                raise ValueError(
                    f"no continuity found for {start=}. Need to have state "
                    f"transitions following first command at {cmds[0]['date']} "
                    "so use a later start date."
                ) from None
            else:
                raise

    # Get transitions, which is a list of dict (state key
    # and new state value at that date).  This goes through each active
    # transition class and accumulates transitions.
    transitions = get_transitions_list(cmds, state_keys_all, start, stop, continuity)

    # List of dict to hold state values.  Datestarts is the corresponding list of
    # start dates for each state.
    states = [StateDict(dict.fromkeys(state_keys_all, None))]
    datestarts = [start]

    # Apply initial ``continuity`` values.  Clear the trans_keys set after setting
    # first state.
    for key, val in continuity.items():
        if key in state_keys_all:
            states[0][key] = val
    states[0].trans_keys.clear()

    # Do main state transition processing.  Start by making current ``state`` which is a
    # reference the last state in the list.
    state = states[0]

    # List of transitions that occur *after* the ``stop`` date but are needed for
    # continuity.  Classic example is for maneuvers if starting in the middle of a
    # maneuver, but this also occurs for SPMEnableTransition which puts commands
    # into the future.  Collect all these transitions and put into
    # states.meta['continuity_transitions'].  This is mostly only needed for
    # get_continuity().
    continuity_transitions = []

    for idx, transition in enumerate(transitions):
        # If there are state constraints then check that the state satisfies the
        # constraints.  If not then skip this transition. Canonical example is
        # ManeuverTransition which requires that the state be in NMAN.
        if transition.constraint is not None and not transition.constraint(state):
            continue

        date = transition.date

        # Some transition classes (e.g. Maneuver) might put in transitions that
        # extend past the stop time.  Add to a list for potential use in continuity.
        if date > stop:
            continuity_transitions.append(transition)
            continue

        # If transition is at a new date from current state then break the
        # current state and make a new one (as a copy of current).  Note that
        # multiple transitions can be at the same date (from commanding at same
        # date), though that is not the usual case.
        if date != datestarts[-1]:  # TODO: don't break if not state.trans_keys
            state = state.copy()
            states.append(state)
            datestarts.append(date)

        # Process the transition.
        for key, value in transition.items():
            if isinstance(value, TransitionCallback):
                # Special case of a functional transition that calls a function
                # instead of directly updating the state.  The function might itself
                # update the state or it might generate downstream transitions.
                value.callback(date, transitions, state, idx, **value.kwargs)
            else:
                # Normal case of just updating current state

                state[key] = value

    # Make into an astropy Table and set up datestart/stop columns
    out = Table(rows=states, names=state_keys_all)
    out.add_column(datestarts, name="datestart", index=0)
    # Add datestop which is just the previous datestart or end of query for last state.
    datestop = out["datestart"].copy()
    datestop[:-1] = out["datestart"][1:]
    datestop[-1] = stop
    out.add_column(datestop, name="datestop", index=1)

    # Add corresponding tstart, tstop
    out.add_column(date2secs(out["datestart"]), name="tstart", index=2)
    out.add_column(date2secs(out["datestop"]), name="tstop", index=3)
    out["tstart"].info.format = ".3f"
    out["tstop"].info.format = ".3f"
    out["trans_keys"] = [st.trans_keys for st in states]

    comp_transition_classes = {
        cls for key in state_keys if (cls := COMP_STATES.get(key))
    }

    if reduce:
        comp_input_keys = set()
        comp_output_keys = set()
        for cls in comp_transition_classes:
            comp_input_keys |= set(cls.state_keys_input)
            comp_output_keys |= set(cls.state_keys)
        reduce_keys = list((set(state_keys) - comp_output_keys) | comp_input_keys)
        out = reduce_states(out, reduce_keys, merge_identical=False)

    for cls in comp_transition_classes:
        for key, vals in cls.calc(out).items():
            out[key] = vals
            for trans_keys, (val1, val2) in zip(
                itertools.islice(out["trans_keys"], 1, None),
                itertools.pairwise(vals),
            ):
                if val1 != val2:
                    trans_keys.add(key)

    if reduce:
        out = reduce_states(out, state_keys, merge_identical)

    # See long comment where continuity_transitions is defined
    out.meta["continuity_transitions"] = continuity_transitions

    return out


def get_associated_state_keys(state_keys):
    """
    Return the full set of state keys that are associated with the requested keys.

    Go through each transition class which impacts desired state keys and accumulate
    all the state keys that the classes touch.  For instance if user requests
    state_keys=['q1'] then we actually need to process all the PCAD_states state keys
    and then at the end reduce down to the requested keys.
    """
    state_keys_assoc = []
    for state_key in state_keys:
        # Get list of transition classes that impact this state key and accumlate the
        # state keys that these classes impact.
        if clss := TRANSITIONS.get(state_key):
            for cls in clss:
                state_keys_assoc.extend(cls.state_keys)

        # Get computed state class that is impacted by this state key. This is unique,
        # unlike transition classes.
        if cls := COMP_STATES.get(state_key):
            state_keys_assoc.extend(cls.state_keys_input)

            # For each computed class dependent state key, get the state keys from
            # transition classes that impact it.
            for key in cls.state_keys_input:
                if clss := TRANSITIONS.get(key):
                    for cls in clss:
                        state_keys_assoc.extend(cls.state_keys)

    # Remove duplicates while preserving order and return
    state_keys_assoc = _unique(state_keys_assoc)
    return state_keys_assoc


def reduce_states(states, state_keys, merge_identical=False, all_keys=False) -> Table:
    """
    Reduce input ``states`` so only transitions in ``state_keys`` are in output.

    By default this also reduces the states table to only include columns for
    those ``state_keys``, but if the ``all_keys`` argument is ``True`` then all
    columns are included in the output.

    By default, the output table will reflect every state transition generated
    by commands even if this does not change the state value.  This allows
    uniquely identifying the time of such commanding related to a state value.
    A common example of transition commanding that does not change state is the
    pair of ACIS stop science commands, where the second is redundant.

    However, if ``merge_identical`` is True then adacent states with identical
    values will be merged.

    Parameters
    ----------
    states
        table of states
    state_keys
        notice transitions in this list of state keys
    merge_identical
        merge adjacent identical states
    all_keys
        if True, then all state keys are included in the output

    Returns
    -------
    Table of reduced states
    """
    if not isinstance(states, Table):
        states = Table(states)

    has_transitions = {
        state_key: np.zeros(len(states), dtype=bool) for state_key in state_keys
    }
    has_transition = np.zeros(len(states), dtype=bool)

    for key in state_keys:
        # Get array where this key has transitions
        if merge_identical:
            col = states[key]
            has_transitions[key][1:] |= col[:-1] != col[1:]
        else:
            has_trans = has_transitions[key]
            for ii, trans_keys in enumerate(states["trans_keys"]):
                has_trans[ii] = key in trans_keys
        has_transitions[key][0] = True

        # Master array if *any* key has a transition
        has_transition |= has_transitions[key]

    # Create output with desired state keys and only states with a transition
    if all_keys:
        out = states
    else:
        out = states[["datestart", "datestop", "tstart", "tstop"] + list(state_keys)]
    out = out[has_transition]

    for dt in ("date", "t"):
        out[f"{dt}stop"][:-1] = out[f"{dt}start"][1:]
        out[f"{dt}stop"][-1] = states[f"{dt}stop"][-1]

    trans_keys_list = [TransKeysSet() for _ in range(len(out))]
    for key in state_keys:
        # Filter transitions for this key based on master filter (from creation
        # of `out`). Then get the index for these transitions.
        has_trans = has_transitions[key][has_transition]
        idxs = np.flatnonzero(has_trans)
        for idx in idxs:
            trans_keys_list[idx].add(key)

    # First state trans_keys is the transition keys from continuity.  Reduce
    # this by set intersection to the output state_keys.
    if "trans_keys" in states.colnames:
        trans_keys_list[0] = states["trans_keys"][0] & set(state_keys)

    out["trans_keys"] = trans_keys_list

    return out


def get_continuity(
    date=None,
    state_keys=None,
    lookbacks=(7, 30, 180, 1000),
    scenario=None,
    event_filter=None,
):
    """
    Get the state and transition dates at ``date`` for ``state_keys``.

    This function finds the state at a particular date by fetching commands
    prior to that date and determine the states.  It returns dictionary
    ``continuity`` provides the state values. Included in this dict is a special
    key ``__dates__`` which provides the corresponding date at which the
    state-changing command occurred.

    Since some state keys like ``pitch`` change often (many times per day) while
    others like ``letg`` may not change for weeks, this function does dynamic
    lookbacks from ``date`` to find transitions for each key.  By default it
    will try looking back 7 days, then 30 days, then 180 days, and finally 1000
    days.  This lookback sequence can be controlled with the ``lookbacks``
    argument.

    If ``state_keys`` is ``None`` then the default keys ``states.DEFAULT_STATE_KEYS``
    is used.  This corresponds to the "classic" Chandra commanded states (obsid,
    ACIS, PCAD, and mechanisms).

    Parameters
    ----------
    date
        date (DateTime compatible, default=NOW)
    state_keys
        list of state keys or str (one state key) or None
    lookbacks
        list of lookback times in days (default=[7, 30, 180, 1000])
    scenario
        commands archive scenario (default=None)
    event_filter : callable, list of callable, None
        Callable function or list of callable functions that takes an Event Table as
        input and returns a boolean mask with same length as Table. This is used to
        select rows from the Table. If None, no filtering is done.

    Returns
    -------
    dict of state values
    """
    if isinstance(state_keys, str):
        state_keys = [state_keys]

    lookbacks = sorted(lookbacks)
    stop = DateTime(date)
    if state_keys is None:
        state_keys = DEFAULT_STATE_KEYS

    continuity = {}
    dates = {}

    # List of transitions that occur *after* the ``stop`` date but are still needed
    # to compute states.  Classic example is for maneuvers, but this also occurs for
    # SPMEnableTransition which puts commands into the future.  Collect all these
    # transitions and eventually add to the output continuity dict as the
    # __transitions__ key.  Then ``get_states`` uses this to initialize transitions.
    continuity_transitions = []

    for lookback in lookbacks:
        start = stop - lookback
        cmds = commands.get_cmds(
            start, stop, scenario=scenario, event_filter=event_filter
        )
        if len(cmds) == 0:
            continue

        for state_key in state_keys:
            # Don't bother if we already have a value for this key.
            if state_key in continuity:
                continue

            # Get available commanded states for this particular state_key.
            # This may return state values for many more keys (e.g.
            # PCAD-related), and some or all of these might be None if the
            # relevant command never happened.  Fill in continuity as possible
            # from last state (corresponding to the state after the last command
            # in cmds).
            try:
                # Note that we need to specify start and stop to ensure that the
                # states span the required time range. Without this the time
                # range of cmds is used which can give unexpected outputs if
                # ``date``` is within a maneuver.
                states = get_states(
                    state_keys=state_key,
                    cmds=cmds,
                    start=start,
                    stop=stop,
                    continuity={},
                    reduce=False,
                    scenario=scenario,
                    event_filter=event_filter,
                )
            except NoTransitionsError:
                # No transitions within `cmds` for state_key, continue with other keys
                continue
            else:
                # get_states() sets this meta value with a list of transitions
                # that were beyond the stop time and did not get processed.
                continuity_transitions.extend(states.meta["continuity_transitions"])

            colnames = set(states.colnames) - {
                "datestart",
                "datestop",
                "tstart",
                "tstop",
                "trans_keys",
            }
            for colname in colnames:
                if states[colname][-1] is not None:
                    # Reduce states to only the desired state_key
                    red_states = reduce_states(states, [colname])
                    continuity[colname] = red_states[colname][-1]
                    dates[colname] = red_states["datestart"][-1]

        # If we have filled in continuity for every key then we're done.
        # Otherwise bump the lookback and try again.
        if all(state_key in continuity for state_key in state_keys):
            break
    else:
        # Didn't find all state keys
        missing_keys = set(state_keys) - set(continuity)

        # Try to get defaults from transition classes
        for missing_key in missing_keys:
            for cls in get_transition_classes(missing_key):
                if hasattr(cls, "default_value"):
                    continuity[missing_key] = cls.default_value
                    dates[missing_key] = "DEFAULT"

        # Try again...
        missing_keys = set(state_keys) - set(continuity)
        if missing_keys:
            raise ValueError(
                "did not find transitions for state key(s)"
                " {} within {} days of {}.  Maybe adjust "
                "the `lookbacks` argument?".format(
                    missing_keys, lookbacks[-1], stop.date
                )
            )

    # Finally reduce down to the state_keys the user requested
    continuity = {key: continuity[key] for key in state_keys}
    dates = {key: dates[key] for key in state_keys}
    continuity["__dates__"] = dates

    # List of transitions needed to fully express continuity.  See long comment above.
    if continuity_transitions:
        continuity["__transitions__"] = continuity_transitions

    return continuity


def interpolate_states(states, times):
    """Interpolate ``states`` table at given times.

    For any ``times`` that are before or after the range of the states table, the
    output state will be the first or last state, respectively..

    Parameters
    ----------
    states
        states (astropy states Table)
    times
        times (np.array or any DateTime compatible input)

    Returns
    -------
    ``states`` view at ``times``
    """
    if not isinstance(times, np.ndarray) or times.dtype.kind != "f":
        times = DateTime(times).secs

    try:
        tstops = states["tstop"]
    except (ValueError, KeyError):
        tstops = date2secs(states["datestop"])

    indexes = np.searchsorted(tstops, times)
    out = states[indexes.clip(0, len(states) - 1)]
    out.add_column(secs2date(times), name="date", index=0)

    return out


def _unique(seq):
    """Return unique elements of ``seq`` in order"""
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]


def print_state_keys_transition_classes_docs():
    """
    Sort transition classes into a data structure keyed by state_keys
    """
    state_keys_classes = collections.defaultdict(list)
    for cls in TRANSITION_CLASSES:
        keys = tuple(cls.state_keys)
        state_keys_classes[keys].append(cls)

    for keys in sorted(state_keys_classes):
        print(", ".join("``{}``".format(key) for key in keys))
        for cls in sorted(state_keys_classes[keys], key=lambda cls: cls.__name__):
            print("  - :class:`~{}.{}`".format(cls.__module__, cls.__name__))
        print()


def get_chandra_states(main_args=None):
    """
    Command line interface to output commanded states over a date range.

    The output is in tabular form to stdout or a file.
    """
    import argparse

    from astropy.io import ascii

    descr = (
        "Ouput the Chandra commanded states over a date range "
        "as a space-delimited ASCII table."
    )
    parser = argparse.ArgumentParser(description=descr)
    parser.add_argument("--start", help="Start date (default=Now-10 days)")
    parser.add_argument("--stop", help="Stop date (default=None)")
    parser.add_argument("--state-keys", help="Comma-separated list of state keys")
    parser.add_argument(
        "--merge-identical",
        default=False,
        action="store_true",
        help="Merge adjacent states that have identical values (default=False)",
    )
    parser.add_argument("--outfile", help="Output file (default=stdout)")

    opt = parser.parse_args(main_args)

    start = DateTime() - 10 if opt.start is None else DateTime(opt.start)
    stop = DateTime(opt.stop)
    state_keys = opt.state_keys.split(",") if opt.state_keys else None
    states = get_states(start, stop, state_keys, merge_identical=opt.merge_identical)
    del states["trans_keys"]
    del states["tstart"]
    del states["tstop"]

    ascii.write(states, output=opt.outfile, format="fixed_width", delimiter="")
