"""
This module provides the functions for dynamically determining Chandra commanded states
based entirely on known history of commands.
"""
import collections
import contextlib
import inspect
import itertools
import re

import astropy.units as u
import Chandra.Maneuver
import numpy as np
import Ska.Sun
from astropy.table import Column, Table
from Chandra.Time import DateTime, date2secs, secs2date
from cxotime import CxoTime
from Quaternion import Quat

from . import commands

# Registry of Transition classes with state transition name as key.  A state transition
# may be generated by several different transition classes, hence the dict value is a list
TRANSITIONS = collections.defaultdict(list)

# Set of all Transition classes
TRANSITION_CLASSES = set()

# Ordered list of all state keys
STATE_KEYS = []

# Quaternion componenent names
QUAT_COMPS = ["q1", "q2", "q3", "q4"]

# State keys for PCAD-related transitions.  If *any* of these are requested then
# *all* of them need to be processed to get the correct answer.
PCAD_STATE_KEYS = (
    QUAT_COMPS
    + ["targ_" + qc for qc in QUAT_COMPS]
    + ["ra", "dec", "roll"]
    + ["auto_npnt", "pcad_mode", "pitch", "off_nom_roll"]
)

# Default state keys (mostly matches classic command states list)
DEFAULT_STATE_KEYS = (
    "ccd_count",
    "clocking",
    "dec",
    "dither",
    "fep_count",
    "hetg",
    "letg",
    "obsid",
    "off_nom_roll",
    "pcad_mode",
    "pitch",
    "power_cmd",
    "q1",
    "q2",
    "q3",
    "q4",
    "ra",
    "roll",
    "si_mode",
    "simfa_pos",
    "simpos",
    "targ_q1",
    "targ_q2",
    "targ_q3",
    "targ_q4",
    "vid_board",
)


@contextlib.contextmanager
def disable_grating_move_duration():
    """
    Temporarily disable the grating move duration
    """
    apply_move_duration = MechMove.apply_move_duration
    MechMove.apply_move_duration = False
    yield
    MechMove.apply_move_duration = apply_move_duration


class NoTransitionsError(ValueError):
    """No transitions found within commands"""

    pass


class TransKeysSet(set):
    """Like set() but with more compact str output for table printing"""

    def __str__(self):
        return ",".join(sorted(self))

    def __and__(self, other):
        return TransKeysSet(super(TransKeysSet, self).__and__(other))


class StateDict(dict):
    """
    Dict for state key/val pairs.  When a key value is set the key is stored
    in the trans_keys attribute.
    """

    def __init__(self, *args, **kwargs):
        super(StateDict, self).__init__(*args, **kwargs)
        self.trans_keys = TransKeysSet()

    def __setitem__(self, key, val):
        super(StateDict, self).__setitem__(key, val)
        self.trans_keys.add(key)

    def copy(self):
        """Copy without trans_keys"""
        return StateDict(self)


###################################################################
# Transition base classes
###################################################################


class TransitionMeta(type):
    """
    Metaclass that adds the class to the TRANSITIONS dict (keyed by state_key),
    the TRANSITIONS_CLASSES set, and makes the complete list of STATE_KEYS.
    """

    def __new__(mcls, name, bases, members):
        cls = super(TransitionMeta, mcls).__new__(mcls, name, bases, members)

        # Register transition classes that have a `state_keys` (base classes do
        # not have this attribute set).
        if hasattr(cls, "state_keys"):
            for state_key in cls.state_keys:
                if state_key not in STATE_KEYS:
                    STATE_KEYS.append(state_key)
                TRANSITIONS[state_key].append(cls)

            TRANSITION_CLASSES.add(cls)

            cls._auto_update_docstring()

        return cls


class BaseTransition(object, metaclass=TransitionMeta):
    """
    Base transition class from which all actual transition classes are derived.
    """

    @classmethod
    def get_state_changing_commands(cls, cmds):
        """
        Get commands that match the required attributes for state changing commands.

        This depends on two class attributes that are defined in derived classes:

        ``command_attributes`` (required)
          dict of {cmd_attr: match_value, ..}, where ``cmd_attr`` is either ``type``
          or ``tlmsid``, and ``match_value`` is the required value.

        ``command_params`` (optional)
          dict of {cmd_attr: match_value, ..}, where ``cmd_attr`` is one of the
          available command parameters, and ``match_value`` is either the required value
          or a list of required values (where at least one must match).

        :param cmds: commands (:class:`~kadi.commands.commands.CommandTable`)

        :returns: subset of ``cmds`` relevant for this Transition class (CmdList)
        """
        # First filter on command attributes.  These
        ok = np.ones(len(cmds), dtype=bool)
        for attr, val in cls.command_attributes.items():
            ok = ok & (cmds[attr] == val)

        out_cmds = cmds[ok]

        # Second do command_params.  Note could use `cmds[attr] == val`for "vectorized"
        # compare, but unrolling the loop here is more efficient since the CmdList class
        # would internally assemble a pure-Python version of the column first.
        if hasattr(cls, "command_params"):
            attrs_list = list(cls.command_params.keys())
            vals_list = [
                val if isinstance(val, list) else [val]
                for val in cls.command_params.values()
            ]
            ok = np.ones(len(out_cmds), dtype=bool)
            for idx, cmd in enumerate(out_cmds):
                for attr, vals in zip(attrs_list, vals_list):
                    ok_idx = False
                    for val in vals:
                        ok_idx |= cmd[attr] == val
                    ok[idx] = ok[idx] & ok_idx

            out_cmds = out_cmds[ok]

        return out_cmds

    @classmethod
    def _auto_update_docstring(cls):
        """
        Put some useful information at the top of docstring.
        """
        docs = []
        docs.append("*State keys*: " + ", ".join(cls.state_keys))

        if hasattr(cls, "command_attributes"):
            cmd_attrs = []
            for key, val in cls.command_attributes.items():
                cmd_attrs.append("{}={}".format(key, val))

            if hasattr(cls, "command_params"):
                keys_list = list(cls.command_params.keys())
                vals_list = [
                    val if isinstance(val, list) else [val]
                    for val in cls.command_params.values()
                ]
                for key, vals in zip(keys_list, vals_list):
                    valstr = " or ".join(str(val) for val in vals)
                    cmd_attrs.append("{}={}".format(key, valstr))

            docs.append("")
            docs.append("*Commands*: " + ", ".join(cmd_attrs))

        others = []
        for attr, val in cls.__dict__.items():
            if (
                attr.startswith("_")
                or inspect.ismethod(val)
                or attr in ("state_keys", "command_attributes", "command_params")
            ):
                continue
            others.append("{}={}".format(attr, val))
        if others:
            docs.append("")
            docs.append("*Others*: " + ", ".join(others))

        # Common 4-space indent
        docs = ["    " + doc for doc in docs]

        if cls.__doc__:
            # Get rid of initial new line and any trailing whitespace/newlines
            docs.insert(0, cls.__doc__.lstrip("\n").rstrip())
            docs.insert(1, "    ")

        cls.__doc__ = "\n".join(docs)


class FixedTransition(BaseTransition):
    """
    Transitions for the case of an attribute that gets set to a fixed
    value when the command occurs, e.g. pcad_mode='NMAN' for AONMMODE.

    Class attributes:

    :param transition_key: single transition key or list of transition keys
    :param transition_val: single transition value or list of values
    """

    @classmethod
    def set_transitions(cls, transitions_dict, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        vals = cls.transition_val
        attrs = cls.transition_key

        if not isinstance(vals, list):
            vals = [vals]
        if not isinstance(attrs, list):
            attrs = [attrs]

        for cmd in state_cmds:
            date = cmd["date"]
            for val, attr in zip(vals, attrs):
                transitions_dict[date][attr] = val


class ParamTransition(BaseTransition):
    """
    Transitions for the case of an attribute that gets set to a value defined by
    a command parameter key, e.g. ``obsid`` = ``ID`` parameter of ``COBRQID``
    command.

    Class attributes:

    :param transition_key: single transition key or list of transition keys
    :param cmd_param_key: command parameter name (str or list of str)
    """

    @classmethod
    def set_transitions(cls, transitions_dict, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        # cmds.rev_pars_dict is either None or a weakref to a dict
        rev_pars_dict = rpd() if (rpd := cmds.rev_pars_dict) else None
        state_cmds = cls.get_state_changing_commands(cmds)
        param_keys = cls.cmd_param_key
        names = cls.transition_key

        if not isinstance(param_keys, list):
            param_keys = [param_keys]
        if not isinstance(names, list):
            names = [names]

        for cmd in state_cmds:
            date = cmd["date"]
            cmd_idx = cmd["idx"]
            if rev_pars_dict is None or cmd_idx == -1:
                params = cmd["params"]
            else:
                params = dict(rev_pars_dict[cmd["idx"]])

            for name, param_key in zip(names, param_keys):
                transitions_dict[date][name] = params[param_key]


###################################################################
# CCDM format and subformat transitions
###################################################################


class Format1_Transition(FixedTransition):
    """Transition to telemetry format 1"""

    command_attributes = {"tlmsid": "CSELFMT1"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT1"


class Format2_Transition(FixedTransition):
    """Transition to telemetry format 2"""

    command_attributes = {"tlmsid": "CSELFMT2"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT2"


class Format3_Transition(FixedTransition):
    """Transition to telemetry format 3"""

    command_attributes = {"tlmsid": "CSELFMT3"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT3"


class Format4_Transition(FixedTransition):
    """Transition to telemetry format 4"""

    command_attributes = {"tlmsid": "CSELFMT4"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT4"


class Format5_Transition(FixedTransition):
    """Transition to telemetry format 5"""

    command_attributes = {"tlmsid": "CSELFMT5"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT5"


class Format6_Transition(FixedTransition):
    """Transition to telemetry format 6"""

    command_attributes = {"tlmsid": "CSELFMT6"}
    state_keys = ["format"]
    transition_key = "format"
    transition_val = "FMT6"


class SubFormatEPS_Transition(FixedTransition):
    """Transition to telemetry EPS subformat"""

    command_attributes = {"tlmsid": "OFMTSEPS"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "EPS"


class SubFormatNRM_Transition(FixedTransition):
    """Transition to telemetry NRM subformat"""

    command_attributes = {"tlmsid": "OFMTSNRM"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "NORM"


class SubFormatPDG_Transition(FixedTransition):
    """Transition to telemetry PDG subformat"""

    command_attributes = {"tlmsid": "OFMTSPDG"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "PDG"


class SubFormatSSR_Transition(FixedTransition):
    """Transition to telemetry SSR subformat"""

    command_attributes = {"tlmsid": "OFMTSSSR"}
    state_keys = ["subformat"]
    transition_key = "subformat"
    transition_val = "SSR"


###################################################################
# Mech transitions
###################################################################


class MechMove(FixedTransition):
    """
    Transitions for mech moves that have non-zero duration.

    This adds two transitions per matched command:
    - First one at cmd time with the transition value with ``_MOVE`` appended
    - Second one at cmd time + move_duration with the straight transition value

    This inherits from FixedTransition for the case of an attribute that gets
    set to a fixed value when the command occurs, e.g. pcad_mode='NMAN' for
    AONMMODE.

    Class attributes:

    :param transition_key: single transition key or list of transition keys
    :param transition_val: single transition value or list of values
    :param move_duration: duration of the move (astropy time Quantity)
    :param apply_move_duration: if True, apply the move duration to states
    """

    apply_move_duration = True

    @classmethod
    def set_transitions(cls, transitions_dict, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        vals = cls.transition_val
        attrs = cls.transition_key
        move_duration = cls.move_duration

        if not isinstance(vals, list):
            vals = [vals]
        if not isinstance(attrs, list):
            attrs = [attrs]

        for cmd in state_cmds:
            date_start = CxoTime(cmd["date"])
            date_stop = date_start + move_duration
            for val, attr in zip(vals, attrs):
                if attr == "grating":
                    transitions_dict[date_start.date][attr] = val
                else:
                    # 'letg' or 'hetg' insert/retract status, include the move
                    # interval here
                    if cls.apply_move_duration:
                        transitions_dict[date_start.date][attr] = val + "_MOVE"
                        transitions_dict[date_stop.date][attr] = val
                    else:
                        transitions_dict[date_start.date][attr] = val


class HETG_INSR_Transition(MechMove):
    """HETG insertion"""

    command_attributes = {"tlmsid": "4OHETGIN"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["hetg", "grating"]
    transition_val = ["INSR", "HETG"]
    move_duration = 157 * u.s


class HETG_RETR_Transition(MechMove):
    """HETG retraction"""

    command_attributes = {"tlmsid": "4OHETGRE"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["hetg", "grating"]
    transition_val = ["RETR", "NONE"]
    move_duration = 153 * u.s


class LETG_INSR_Transition(MechMove):
    """LETG insertion"""

    command_attributes = {"tlmsid": "4OLETGIN"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["letg", "grating"]
    transition_val = ["INSR", "LETG"]
    move_duration = 203 * u.s


class LETG_RETR_Transition(MechMove):
    """LETG retraction"""

    command_attributes = {"tlmsid": "4OLETGRE"}
    state_keys = ["letg", "hetg", "grating"]
    transition_key = ["letg", "grating"]
    transition_val = ["RETR", "NONE"]
    move_duration = 203 * u.s


class SimTscTransition(ParamTransition):
    """SIM translating science compartment translation"""

    command_attributes = {"type": "SIMTRANS"}
    state_keys = ["simpos"]
    transition_key = "simpos"
    cmd_param_key = "pos"


class SimFocusTransition(ParamTransition):
    """SIM focus assembly translation"""

    command_attributes = {"type": "SIMFOCUS"}
    state_keys = ["simfa_pos"]
    transition_key = "simfa_pos"
    cmd_param_key = "pos"


###################################################################
# HRC transitions
###################################################################


class Hrc15vOn_Transition(FixedTransition):
    """HRC 15V ON from hardware 215PCAON command"""

    command_attributes = {"tlmsid": "215PCAON"}
    state_keys = ["hrc_15v"]
    transition_key = "hrc_15v"
    transition_val = "ON"


class Hrc15vOn_SCS134_Transition(FixedTransition):
    """HRC 15V ON from SCS-134"""

    command_attributes = {"tlmsid": "COACTSX", "coacts1": 134}
    state_keys = ["hrc_15v"]
    transition_key = "hrc_15v"
    transition_val = "ON"


class Hrc15vOff_Transition(FixedTransition):
    """HRC 15V OFF"""

    command_attributes = {"tlmsid": "215PCAOF"}
    state_keys = ["hrc_15v"]
    transition_key = "hrc_15v"
    transition_val = "OFF"


class Hrc24vOn_Transition(FixedTransition):
    """HRC 24V ON"""

    command_attributes = {"tlmsid": "224PCAON"}
    state_keys = ["hrc_24v"]
    transition_key = "hrc_24v"
    transition_val = "ON"


class Hrc24vOff_Transition(FixedTransition):
    """HRC 24V OFF"""

    command_attributes = {"tlmsid": "224PCAOF"}
    state_keys = ["hrc_24v"]
    transition_key = "hrc_24v"
    transition_val = "OFF"


class HrcIOn_Transition(FixedTransition):
    """HRC-I ON"""

    command_attributes = {"tlmsid": "COENASX", "coenas1": 89}
    state_keys = ["hrc_i"]
    transition_key = "hrc_i"
    transition_val = "ON"


class HrcIOff_Transition(FixedTransition):
    """HRC-I OFF"""

    command_attributes = {
        "tlmsid": "2IMHVOF",
    }
    state_keys = ["hrc_i"]
    transition_key = "hrc_i"
    transition_val = "OFF"


class HrcSOn_Transition(FixedTransition):
    """HRC-S ON"""

    command_attributes = {"tlmsid": "COENASX", "coenas1": 90}
    state_keys = ["hrc_s"]
    transition_key = "hrc_s"
    transition_val = "ON"


class HrcSOff_Transition(FixedTransition):
    """HRC-S OFF"""

    command_attributes = {
        "tlmsid": "2SPHVOF",
    }
    state_keys = ["hrc_s"]
    transition_key = "hrc_s"
    transition_val = "OFF"


###################################################################
# OBC etc transitions
###################################################################


class ObsidTransition(ParamTransition):
    """Obsid update"""

    command_attributes = {"type": "MP_OBSID"}
    state_keys = ["obsid"]
    transition_key = "obsid"
    cmd_param_key = "id"


class EclipseEntryTimerTransition(ParamTransition):
    """Eclipse entry timer update"""

    command_attributes = {"tlmsid": "EOECLETO"}
    state_keys = ["eclipse_timer"]
    transition_key = "eclipse_timer"
    cmd_param_key = "timecnt"


class EclipsePenumbraEntryTransition(FixedTransition):
    """Eclipse penumbra entry"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": ["PENTRY", "LSPENTRY"]}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "PENUMBRA"


class EclipsePenumbraExitTransition(FixedTransition):
    """Eclipse penumbra exit"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": ["PEXIT", "LSPEXIT"]}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "DAY"


class EclipseUmbraEntryTransition(FixedTransition):
    """Eclipse umbra entry"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": "EONIGHT"}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "UMBRA"


class EclipseUmbraExitTransition(FixedTransition):
    """Eclipse umbra exit"""

    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": "EODAY"}
    state_keys = ["eclipse"]
    transition_key = "eclipse"
    transition_val = "PENUMBRA"


class SPMEnableTransition(FixedTransition):
    """Sun position monitor enable"""

    command_attributes = {"tlmsid": "AOFUNCEN"}
    command_params = {"aopcadse": 30}
    state_keys = ["sun_pos_mon"]
    transition_key = "sun_pos_mon"
    transition_val = "ENAB"


class SPMDisableTransition(FixedTransition):
    """Sun position monitor disable"""

    command_attributes = {"tlmsid": "AOFUNCDS"}
    command_params = {"aopcadsd": 30}
    state_keys = ["sun_pos_mon"]
    transition_key = "sun_pos_mon"
    transition_val = "DISA"


class SPMEclipseEnableTransition(BaseTransition):
    """
    Automatic enable of sun position monitor which occurs 11 minutes after eclipse exit,
    but only if the battery-connect command occurs within 2:05 minutes of eclipse entry.

    Connect batteries is an event type COMMAND_SW and TLMSID= EOESTECN
    Eclipse entry is event type ORBPOINT with TYPE=PENTRY or TYPE=LSPENTRY
    Eclipse exit is event type ORBPOINT with TYPE=PEXIT or TYPE=LSPEXIT
    """

    # Command attributes and params are just for docstring, but actual transition
    # command filtering in set_transitions is more complicated.
    command_attributes = {"type": "ORBPOINT"}
    command_params = {"event_type": ["PEXIT", "LSPEXIT"]}
    state_keys = ["sun_pos_mon"]

    @classmethod
    def set_transitions(cls, transitions_dict, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        # Preselect only commands that might have an impact here.
        ok = (cmds["tlmsid"] == "EOESTECN") | (cmds["type"] == "ORBPOINT")
        cmds = cmds[ok]

        connect_time = 0
        connect_flag = False

        for cmd in cmds:
            if cmd["tlmsid"] == "EOESTECN":
                connect_time = DateTime(cmd["date"]).secs

            elif cmd["type"] == "ORBPOINT":
                if cmd["event_type"] in ("PENTRY", "LSPENTRY"):
                    entry_time = DateTime(cmd["date"]).secs
                    connect_flag = entry_time - connect_time < 125

                elif cmd["event_type"] in ("PEXIT", "LSPEXIT") and connect_flag:
                    scs33 = (
                        DateTime(cmd["date"]) + 11 * 60 / 86400
                    )  # 11 minutes in days
                    transitions_dict[scs33.date]["sun_pos_mon"] = "ENAB"
                    connect_flag = False


class SCS84EnableTransition(FixedTransition):
    """SCS-84 enable"""

    command_attributes = {"tlmsid": "COENASX"}
    command_params = {"coenas1": 84}
    state_keys = ["scs84"]
    transition_key = "scs84"
    transition_val = "ENAB"
    default_value = "DISA"


class SCS84DisableTransition(FixedTransition):
    """SCS-84 disable"""

    command_attributes = {"tlmsid": "CODISASX"}
    command_params = {"codisas1": 84}
    state_keys = ["scs84"]
    transition_key = "scs84"
    transition_val = "DISA"


class SCS98EnableTransition(FixedTransition):
    """SCS-98 enable"""

    command_attributes = {"tlmsid": "COENASX"}
    command_params = {"coenas1": 98}
    state_keys = ["scs98"]
    transition_key = "scs98"
    transition_val = "ENAB"


class SCS98DisableTransition(FixedTransition):
    """SCS-98 disable"""

    command_attributes = {"tlmsid": "CODISASX"}
    command_params = {"codisas1": 98}
    state_keys = ["scs98"]
    transition_key = "scs98"
    transition_val = "DISA"


class RadmonEnableTransition(FixedTransition):
    """RADMON enable"""

    command_attributes = {"tlmsid": "OORMPEN"}
    state_keys = ["radmon"]
    transition_key = "radmon"
    transition_val = "ENAB"


class RadmonDisableTransition(FixedTransition):
    """RADMON disable"""

    command_attributes = {"tlmsid": "OORMPDS"}
    state_keys = ["radmon"]
    transition_key = "radmon"
    transition_val = "DISA"


class OrbitPointTransition(ParamTransition):
    """Orbit point state based on backstop ephemeris entries"""

    command_attributes = {"type": "ORBPOINT"}
    state_keys = ["orbit_point"]
    transition_key = "orbit_point"
    cmd_param_key = "event_type"


class EphemerisTransition(ParamTransition):
    """On-board ephemeris update values"""

    command_attributes = {"tlmsid": "AOEPHUPS"}
    state_keys = [
        "aoephem1",
        "aoephem2",
        "aoratio",
        "aoargper",
        "aoeccent",
        "ao1minus",
        "ao1plus",
        "aomotion",
        "aoiterat",
        "aoorbang",
        "aoperige",
        "aoascend",
        "aosini",
        "aoslr",
        "aosqrtmu",
    ]
    transition_key = state_keys
    cmd_param_key = state_keys


class EphemerisUpdateTransition(BaseTransition):
    """
    On-board ephemeris update date.  Mostly useful for the FOT to assist in backstop
    processing.
    """

    command_attributes = {"tlmsid": "AOEPHUPS"}
    state_keys = ["ephem_update"]

    @classmethod
    def set_transitions(cls, transitions_dict, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            date = cmd["date"]
            transitions_dict[date]["ephem_update"] = date[:8]


###################################################################


class SunVectorTransition(BaseTransition):
    """
    Add transitions between start/stop every 10 ksec to sample the pitch and off_nominal
    roll during NPNT.  These are function transitions which check to see that
    ``pcad_mode == 'NPNT'`` before changing the pitch / off_nominal_roll.
    """

    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions_dict, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        # np.ceil is used here to get 'times' between start/stop at even
        # increments of "sample_time" so that the commands will be at the same
        # times in an interval even if a different time range is being updated.
        sample_time = 10000
        tstart = np.ceil(DateTime(start).secs / sample_time) * sample_time
        tstop = DateTime(stop).secs
        times = np.arange(tstart, tstop, sample_time)
        dates = DateTime(times).date

        # Now with the dates, finally make all the transition dicts which will
        # call `update_pitch_state` during state processing.
        for date in dates:
            transitions_dict[date]["update_sun_vector"] = cls.update_sun_vector_state

    @classmethod
    def update_sun_vector_state(cls, date, transitions, state, idx):
        """
        Transition callback method to potentially update the ``pitch`` and
        ``off_nominal`` states if pcad_mode is NPNT.

        :param date: date (str)
        :param transitions: global list of transitions
        :param state: current state (dict)
        :param idx: current index into transitions
        """
        if state["pcad_mode"] == "NPNT":
            q_att = Quat([state[qc] for qc in QUAT_COMPS])
            state["pitch"] = Ska.Sun.pitch(q_att.ra, q_att.dec, date)
            state["off_nom_roll"] = Ska.Sun.off_nominal_roll(q_att, date)


class DitherEnableTransition(FixedTransition):
    """Dither enable"""

    command_attributes = {"tlmsid": "AOENDITH"}
    state_keys = ["dither"]
    transition_key = "dither"
    transition_val = "ENAB"


class DitherDisableTransition(FixedTransition):
    """Dither disable"""

    command_attributes = {"tlmsid": "AODSDITH"}
    state_keys = ["dither"]
    transition_key = "dither"
    transition_val = "DISA"


class DitherParamsTransition(BaseTransition):
    """Dither parameters"""

    command_attributes = {"tlmsid": "AODITPAR"}
    state_keys = [
        "dither_phase_pitch",
        "dither_phase_yaw",
        "dither_ampl_pitch",
        "dither_ampl_yaw",
        "dither_period_pitch",
        "dither_period_yaw",
    ]

    @classmethod
    def set_transitions(cls, transitions_dict, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            dither = {
                "dither_phase_pitch": np.degrees(cmd["angp"]),
                "dither_phase_yaw": np.degrees(cmd["angy"]),
                "dither_ampl_pitch": np.degrees(cmd["coefp"]) * 3600,
                "dither_ampl_yaw": np.degrees(cmd["coefy"]) * 3600,
                "dither_period_pitch": 2 * np.pi / cmd["ratep"],
                "dither_period_yaw": 2 * np.pi / cmd["ratey"],
            }
            transitions_dict[cmd["date"]].update(dither)


class NMM_Transition(FixedTransition):
    """Transition to Normal Maneuver Mode"""

    command_attributes = {"tlmsid": "AONMMODE"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "pcad_mode"
    transition_val = "NMAN"


class NPM_Transition(FixedTransition):
    """Transition to Normal Point Mode"""

    command_attributes = {"tlmsid": "AONPMODE"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "pcad_mode"
    transition_val = "NPNT"


class AutoNPMEnableTransition(FixedTransition):
    """Enable automatic transition to Normal Point Mode"""

    command_attributes = {"tlmsid": "AONM2NPE"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "auto_npnt"
    transition_val = "ENAB"


class AutoNPMDisableTransition(FixedTransition):
    """Disable automatic transition to Normal Point Mode"""

    command_attributes = {"tlmsid": "AONM2NPD"}
    state_keys = PCAD_STATE_KEYS
    transition_key = "auto_npnt"
    transition_val = "DISA"


class TargQuatTransition(BaseTransition):
    """Commanded target quaternion"""

    command_attributes = {"type": "MP_TARGQUAT"}
    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transition = transitions[cmd["date"]]
            for qc in ("q1", "q2", "q3", "q4"):
                transition["targ_" + qc] = cmd[qc]


class ManeuverTransition(BaseTransition):
    """
    Execute maneuver.  This is a relatively complex transition that computes the
    intermediate quaternion values for the maneuver and inserts downstream transitions to
    perform attitude quaternion updated accordingly.  At the end of the maneuver it
    schedules a NPM transition if ``auto_npnt`` is enabled.
    """

    command_attributes = {"tlmsid": "AOMANUVR"}
    state_keys = PCAD_STATE_KEYS

    @classmethod
    def set_transitions(cls, transitions, cmds, start, stop):
        state_cmds = cls.get_state_changing_commands(cmds)

        for cmd in state_cmds:
            transitions[cmd["date"]]["maneuver_transition"] = cls.callback

    @classmethod
    def callback(cls, date, transitions, state, idx):
        """
        Transition function callback to generate downstream transitions to perform the
        actual maneuver and (usually) transition to NPM at the end of maneuver.
        """
        end_manvr_date = cls.add_manvr_transitions(date, transitions, state, idx)

        # If no target attitude has been defined to this point then we cannot
        # do state processing for a maneuver, so drop it on the floor.
        if end_manvr_date is None:
            return

        # If auto-transition to NPM after manvr is enabled (this is
        # normally the case) then back to NPNT at end of maneuver
        if state["auto_npnt"] == "ENAB":
            transition = {"date": end_manvr_date, "pcad_mode": "NPNT"}
            add_transition(transitions, idx, transition)

    @classmethod
    def add_manvr_transitions(cls, date, transitions, state, idx):
        """
        This does the main work of adding transitions for a maneuver.  It is
        called by the ManeuverTransition and NormalSunTransition classes.
        """
        # Get the current target attitude state
        targ_att = [state["targ_" + qc] for qc in QUAT_COMPS]

        # Check that target attitude is defined. If start time is between
        # AOUPTARQ and AOMANUVR command then this will happen. In this case just
        # drop the maneuver on the floor, consistent with attitude state being
        # undefined.
        if None in targ_att:
            return None

        # Deal with startup transient where spacecraft attitude is not known.
        # In this case first maneuver is a bogus null maneuver.
        if state["q1"] is None:
            for qc in QUAT_COMPS:
                state[qc] = state["targ_" + qc]

        # Get current spacecraft attitude
        curr_att = [state[qc] for qc in QUAT_COMPS]

        # Get attitudes for the maneuver at about 5-minute intervals.
        atts = Chandra.Maneuver.attitudes(
            curr_att, targ_att, tstart=DateTime(date).secs
        )

        # Compute pitch and off-nominal roll at the midpoint of each interval, except
        # also include the exact last attitude.
        pitches = np.hstack([(atts[:-1].pitch + atts[1:].pitch) / 2, atts[-1].pitch])
        off_nom_rolls = np.hstack(
            [
                (atts[:-1].off_nom_roll + atts[1:].off_nom_roll) / 2,
                atts[-1].off_nom_roll,
            ]
        )

        # Add transitions for each bit of the maneuver.  Note that this sets the attitude
        # (q1..q4) at the *beginning* of each state, while setting pitch and
        # off_nominal_roll at the *midpoint* of each state.  This is for legacy
        # compatibility with Chandra.cmd_states but might be something to change since it
        # would probably be better to have the midpoint attitude.
        for att, pitch, off_nom_roll in zip(atts, pitches, off_nom_rolls):
            date = DateTime(att.time).date
            transition = {"date": date}
            for qc in QUAT_COMPS:
                transition[qc] = att[qc]
            transition["pitch"] = pitch
            transition["off_nom_roll"] = off_nom_roll

            q_att = Quat([att[x] for x in QUAT_COMPS])
            transition["ra"] = q_att.ra
            transition["dec"] = q_att.dec
            transition["roll"] = q_att.roll

            add_transition(transitions, idx, transition)

        return date  # Date of end of maneuver.


class NormalSunTransition(ManeuverTransition):
    """
    Same as ``ManeuverTransition`` except that it performs a maneuver
    to a normal sun pointed attitude (based on a pure-pitch maneuver from
    current attitude).  It also changes ``pcad_mode`` to NSUN.
    """

    command_attributes = {"tlmsid": "AONSMSAF"}
    state_keys = PCAD_STATE_KEYS

    @classmethod
    def callback(cls, date, transitions, state, idx):
        """
        This is a transition function callback.  It directly sets the state
        pcad_mode to NSUN and target quaternion to the expected sun pointed
        attitude.  It then calls the parent method to add the actual maneuver.
        """
        # Transition to NSUN
        state["pcad_mode"] = "NSUN"

        # Setup for maneuver to sun-pointed attitude from current att
        curr_att = [state[qc] for qc in QUAT_COMPS]

        # If current attitude is not defined then just drop the NSM maneuver on
        # the floor. The state will start getting defined when the first normal
        # maneuver happens.
        if None in curr_att:
            return

        targ_att = Chandra.Maneuver.NSM_attitude(curr_att, date)
        for qc, targ_q in zip(QUAT_COMPS, targ_att.q):
            state["targ_" + qc] = targ_q

        # Do the maneuver
        cls.add_manvr_transitions(date, transitions, state, idx)


###################################################################
# ACIS transitions
###################################################################
def decode_power(mnem):
    """
    Decode number of chips and feps from a ACIS power command
    Return a dictionary with the number of chips and their identifiers

    Example:

    >>> decode_power("WSPOW08F3E")
    {'ccd_count': 5,
     'ccds': 'I0 I1 I2 I3 S3 ',
     'clocking': 0,
     'fep_count': 5,
     'feps': '1 2 3 4 5 ',
     'vid_board': 1}

    :param mnem: power command string

    """
    fep_info = {
        "fep_count": 0,
        "ccd_count": 0,
        "feps": "",
        "ccds": "",
        "vid_board": 1,
        "clocking": 0,
    }

    # Special case WSPOW000XX to turn off vid_board
    if mnem.startswith("WSPOW000"):
        fep_info["vid_board"] = 0

    # the hex for the commanding is after the WSPOW
    powstr = mnem[5:]
    if len(powstr) != 5:
        raise ValueError("%s in unexpected format" % mnem)

    # convert the hex to decimal and "&" it with 63 (binary 111111)
    fepkey = int(powstr, 16) & 63
    # count the true binary bits
    for bit in range(0, 6):
        if fepkey & (1 << bit):
            fep_info["fep_count"] = fep_info["fep_count"] + 1
            fep_info["feps"] = fep_info["feps"] + str(bit) + " "

    # convert the hex to decimal and right shift by 8 places
    vidkey = int(powstr, 16) >> 8

    # count the true bits
    for bit in range(0, 10):
        if vidkey & (1 << bit):
            fep_info["ccd_count"] = fep_info["ccd_count"] + 1
            # position indicates I or S chip
            if bit < 4:
                fep_info["ccds"] = fep_info["ccds"] + "I" + str(bit) + " "
            else:
                fep_info["ccds"] = fep_info["ccds"] + "S" + str(bit - 4) + " "

    return fep_info


class ACISTransition(BaseTransition):
    """
    Implement transitions for ACIS states.
    """

    command_attributes = {"type": "ACISPKT"}
    state_keys = [
        "clocking",
        "power_cmd",
        "vid_board",
        "fep_count",
        "si_mode",
        "ccd_count",
    ]

    @classmethod
    def set_transitions(cls, transitions, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        for cmd in state_cmds:
            tlmsid = cmd["tlmsid"]
            date = cmd["date"]

            if tlmsid.startswith("WSPOW"):
                pwr = decode_power(tlmsid)
                transitions[date].update(
                    fep_count=pwr["fep_count"],
                    ccd_count=pwr["ccd_count"],
                    vid_board=pwr["vid_board"],
                    clocking=pwr["clocking"],
                    power_cmd=tlmsid,
                )

            elif tlmsid in ("XCZ0000005", "XTZ0000005"):
                transitions[date].update(clocking=1, power_cmd=tlmsid)

            elif tlmsid == "WSVIDALLDN":
                transitions[date].update(vid_board=0, ccd_count=0, power_cmd=tlmsid)

            elif tlmsid == "AA00000000":
                transitions[date].update(clocking=0, power_cmd=tlmsid)

            elif tlmsid == "WSFEPALLUP":
                transitions[date].update(fep_count=6, power_cmd=tlmsid)

            elif tlmsid.startswith("WC"):
                transitions[date].update(si_mode="CC_" + tlmsid[2:7])

            # Two special-case raw-mode SI modes
            # (https://github.com/sot/cmd_states/issues/23)
            elif tlmsid == "WT000B5024":
                transitions[date].update(si_mode="TN_000B4")

            elif tlmsid == "WT000B7024":
                transitions[date].update(si_mode="TN_000B6")

            elif tlmsid.startswith("WT"):
                transitions[date].update(si_mode="TE_" + tlmsid[2:7])


class ACISFP_SetPointTransition(BaseTransition):
    """
    Implement transitions for ACIS focal plane temperature setpoint state.

    Looks for ACISPKT commands with TLMSID like ``WSFTNEG<number>``, where the
    ACIS FP setpoint temperature is ``-<number>``.
    """

    command_attributes = {"type": "ACISPKT"}
    state_keys = ["acisfp_setpoint"]
    default_value = -121.0

    @classmethod
    def set_transitions(cls, transitions, cmds, start, stop):
        """
        Set transitions for a Table of commands ``cmds``.

        :param transitions_dict: global dict of transitions (updated in-place)
        :param cmds: commands (CmdList)
        :param start: start time for states
        :param stop: stop time for states

        :returns: None
        """
        state_cmds = cls.get_state_changing_commands(cmds)
        for cmd in state_cmds:
            tlmsid = cmd["tlmsid"]
            date = cmd["date"]

            if tlmsid.startswith("WSFTNEG"):
                match = re.search(r"(\d+)$", tlmsid)
                if not match:
                    raise ValueError(f"unable to parse command {tlmsid}")
                transitions[date].update(acisfp_setpoint=-float(match.group(1)))


###################################################################
# State transitions processing code
###################################################################


def get_transition_classes(state_keys=None):
    """
    Get all BaseTransition subclasses in this module corresponding to
    state keys ``state_keys``.
    """
    if isinstance(state_keys, str):
        state_keys = [state_keys]
    elif state_keys is None:
        state_keys = DEFAULT_STATE_KEYS

    trans_classes = set(
        itertools.chain.from_iterable(
            classes
            for state_key, classes in TRANSITIONS.items()
            if state_key in state_keys
        )
    )

    return trans_classes


def get_transitions_list(cmds, state_keys, start, stop, continuity=None):
    """
    For given set of commands ``cmds`` and ``state_keys``, return a list of
    transitions.

    A ``transition`` here defines a state transition.  It is a dict with a ``date`` key
    (date of transition) and key/value pairs corresponding to the state keys that change.

    If ``state_keys`` is None then all known state keys are included.

    :param cmds: CmdList with spacecraft commands
    :param state_keys: desired state keys (None, str, or list)

    :returns: list of dict (transitions), set of transition classes
    """
    # To start, collect transitions in a dict keyed by date.  This auto-initializes
    # a dict whenever a new date is used, allowing (e.g.) a single step of::
    #
    #   transitions_dict['2017:002:01:02:03.456']['obsid'] = 23456.
    transitions_dict = collections.defaultdict(dict)

    # If an initial list of transitions is provided in the continuity dict
    # then apply those.  These would be transitions that occur after the the
    # continuity time, e.g. in the case continuity in the middle of a maneuver
    # where we need the remaining attitude and pcad_mode transitions.
    if continuity is not None and "__transitions__" in continuity:
        for transition in continuity["__transitions__"]:
            transitions_dict[transition["date"]].update(transition)

    # Iterate through Transition classes which depend on or affect ``state_keys``
    # and ask each one to update ``transitions_dict`` in-place to include
    # transitions from that class.
    for transition_class in get_transition_classes(state_keys):
        transition_class.set_transitions(transitions_dict, cmds, start, stop)

    # Convert the dict of transitions (keyed by date) into an ordered list of transitions
    # sorted by date.  A *list* of transitions is needed to allow a transition to
    # dynamically generate additional (later) transitions, e.g. in the case of a maneuver.
    transitions_list = []
    for date in sorted(transitions_dict):
        transition = transitions_dict[date]
        transition["date"] = date
        transitions_list.append(transition)

    # In the rest of this module ``transitions`` is always this *list* of transitions.
    return transitions_list


def add_transition(transitions, idx, transition):
    """
    Add ``transition`` to the ``transitions`` list at the first appropriate
    place after the ``idx`` entry.

    This is typically used by dynamic transitions that are actually calling a function to
    generate downstream transitions.  The ManeuverTransition class is the canonical
    example.

    :param transitions: global list of transition dicts
    :param idx: current index into transitions in state processing
    :param transition: transition to add (dict)

    :returns: None
    """
    # Prevent adding command before current command since the command
    # interpreter is a one-pass process.
    date = transition["date"]
    if date < transitions[idx]["date"]:
        raise ValueError("cannot insert transition prior to current command")

    # Insert transition at first place where new transition date is strictly
    # less than existing transition date.  This implementation is linear, and
    # could be improved, though in practice transitions are often inserted
    # close to the original.
    for ii in range(idx + 1, len(transitions)):
        if date < transitions[ii]["date"]:
            transitions.insert(ii, transition)
            break
    else:
        transitions.append(transition)


def get_states(
    start=None,
    stop=None,
    state_keys=None,
    cmds=None,
    continuity=None,
    reduce=True,
    merge_identical=False,
    scenario=None,
) -> Table:
    """
    Get table of states corresponding to intervals when ``state_keys`` parameters
    are unchanged given the input commands ``cmds`` or ``start`` date.

    If ``state_keys`` is ``None`` then the default keys
    ``states.DEFAULT_STATE_KEYS`` is used.  This corresponds to the "classic"
    Chandra commanded states (obsid, ACIS, PCAD, and mechanisms).  One can also
    provide a single state key as a a string, e.g. ``state_keys='obsid'``.

    If the ``cmds`` argument is not provided then the ``start`` and ``stop`` are
    used to fetch the commands internally. If the ``stop`` date is not provided
    then all known commands (including future commands from approved loads) will
    be included.

    The output table will contain columns for ``state_keys`` along with
    ``datestart`` and ``datestop`` columns.  By default the ``reduce_states``
    function is called (with the supplied value of ``merge_identical``) in order
    to reduce down to the specified ``state_keys``.

    If ``reduce`` is ``False`` then ``reduce_states`` is not called and output
    table may include additional columns for related states.  For instance in
    order to compute the attitude quaternion state ``q1`` it is necessary to
    collect a number of other states such as ``pcad_mode`` and target
    quaternions ``targ_q1`` through ``targ_q4``.  One can call the
    ``reduce_states()`` function separately to reduce to only the desired state
    keys.

    :param start: start of states (optional, DateTime compatible)
    :param stop: stop of states (optional, DateTime compatible)
    :param state_keys: state keys of interest (optional, list or str or None)
    :param cmds: input commands (optional, CmdList, CommandTable)
    :param continuity: initial state (optional, dict)
    :param reduce: call reduce_states() on output
    :param merge_identical: merge identical states (see reduce_states() docs)
    :param scenario: commands archive scenario to use

    :returns: astropy Table of states
    """
    # Define complete list of column names for output table corresponding to
    # each state key.  Maintain original order and uniqueness of keys.
    if state_keys is None:
        state_keys = DEFAULT_STATE_KEYS
    elif isinstance(state_keys, str):
        state_keys = [state_keys]

    # Go through each transition class which impacts desired state keys and accumulate
    # all the state keys that the classes touch.  For instance if user requests
    # state_keys=['q1'] then we actually need to process all the PCAD_states state keys
    # and then at the end reduce down to the requested keys.
    orig_state_keys = state_keys
    state_keys = []
    for state_key in orig_state_keys:
        for cls in TRANSITION_CLASSES:
            if state_key in cls.state_keys:
                state_keys.extend(cls.state_keys)
    state_keys = _unique(state_keys)

    # Get commands, either from `cmds` arg or from `start` / `stop`
    if cmds is None:
        if start is None:
            raise ValueError("must supply either 'cmds' argument or 'start' argument")
        cmds = commands.get_cmds(start, stop, scenario=scenario)
        start = DateTime(start).date
        stop = DateTime(
            stop or cmds[-1]["date"]
        ).date  # User-supplied stop or last command
    else:
        start = cmds[0]["date"] if start is None else DateTime(start).date
        stop = cmds[-1]["date"] if stop is None else DateTime(stop).date

    # Get initial state at start of commands
    if continuity is None:
        try:
            continuity = get_continuity(start, state_keys, scenario=scenario)
        except ValueError as exc:
            if "did not find transitions" in str(exc):
                raise ValueError(
                    f"no continuity found for {start=}. Need to have state "
                    f'transitions following first command at {cmds[0]["date"]} '
                    "so use a later start date."
                )
            else:
                raise

    # Get transitions, which is a list of dict (state key
    # and new state value at that date).  This goes through each active
    # transition class and accumulates transitions.
    transitions = get_transitions_list(cmds, state_keys, start, stop, continuity)

    # List of dict to hold state values.  Datestarts is the corresponding list of
    # start dates for each state.
    states = [StateDict({key: None for key in state_keys})]
    datestarts = [start]

    # Apply initial ``continuity`` values.  Clear the trans_keys set after setting
    # first state.
    for key, val in continuity.items():
        if key in state_keys:
            states[0][key] = val
    states[0].trans_keys.clear()

    # Do main state transition processing.  Start by making current ``state`` which is a
    # reference the last state in the list.
    state = states[0]

    # List of transitions that occur *after* the ``stop`` date but are needed for
    # continuity.  Classic example is for maneuvers if starting in the middle of a
    # maneuver, but this also occurs for SPMEnableTransition which puts commands
    # into the future.  Collect all these transitions and put into
    # states.meta['continuity_transitions'].  This is mostly only needed for
    # get_continuity().
    continuity_transitions = []

    for idx, transition in enumerate(transitions):
        date = transition["date"]

        # Some transition classes (e.g. Maneuver) might put in transitions that
        # extend past the stop time.  Add to a list for potential use in continuity.
        if date > stop:
            continuity_transitions.append(transition)
            continue

        # If transition is at a new date from current state then break the current state
        # and make a new one (as a copy of current).  Note that multiple transitions can
        # be at the same date (from commanding at same date), though that is not the usual
        # case.
        if date != datestarts[-1]:  # TODO: don't break if not state.trans_keys
            state = state.copy()
            states.append(state)
            datestarts.append(date)

        # Process the transition.
        for key, value in transition.items():
            if inspect.ismethod(value):
                # Special case of a functional transition that calls a function
                # instead of directly updating the state.  The function might itself
                # update the state or it might generate downstream transitions.
                value(date, transitions, state, idx)
            elif key != "date":
                # Normal case of just updating current state
                state[key] = value

    # Make into an astropy Table and set up datestart/stop columns
    out = Table(rows=states, names=state_keys)
    out.add_column(Column(datestarts, name="datestart"), 0)
    # Add datestop which is just the previous datestart.
    datestop = out["datestart"].copy()
    datestop[:-1] = out["datestart"][1:]
    # Final datestop far in the future
    datestop[-1] = stop
    out.add_column(Column(datestop, name="datestop"), 1)

    # Add corresponding tstart, tstop
    out.add_column(Column(date2secs(out["datestart"]), name="tstart"), 2)
    out.add_column(Column(date2secs(out["datestop"]), name="tstop"), 3)
    out["tstart"].info.format = ".3f"
    out["tstop"].info.format = ".3f"

    out["trans_keys"] = [st.trans_keys for st in states]

    if reduce:
        out = reduce_states(out, orig_state_keys, merge_identical)

    # See long comment where continuity_transitions is defined
    out.meta["continuity_transitions"] = continuity_transitions

    return out


def reduce_states(states, state_keys, merge_identical=False, all_keys=False) -> Table:
    """
    Reduce the input ``states`` so that only transitions in the ``state_keys``
    are in the output.

    By default this also reduces the states table to only include
    columns for those ``state_keys``, but if the ``all_keys`` argument is
    ``True`` then all columns are included in the output.

    By default, the output table will reflect every state transition
    generated by commands even if this does not change the state value.  This
    allows uniquely identifying the time of such commanding related to a
    state value.  A common example of transition commanding that does not
    change state is the pair of ACIS stop science commands, where the second
    is redundant.

    However, if ``merge_identical`` is True then adacent states with identical
    values will be merged.

    :param states: table of states
    :param state_keys: notice transitions in this list of state keys
    :param merge_identical: merge adjacent identical states
    :param all_keys: if True, then all state keys are included in the output

    :returns: Table of reduced states
    """
    if not isinstance(states, Table):
        states = Table(states)

    has_transitions = {
        state_key: np.zeros(len(states), dtype=bool) for state_key in state_keys
    }
    has_transition = np.zeros(len(states), dtype=bool)

    for key in state_keys:
        # Get array where this key has transitions
        if merge_identical:
            col = states[key]
            has_transitions[key][1:] |= col[:-1] != col[1:]
        else:
            has_trans = has_transitions[key]
            for ii, trans_keys in enumerate(states["trans_keys"]):
                has_trans[ii] = key in trans_keys
        has_transitions[key][0] = True

        # Master array if *any* key has a transition
        has_transition |= has_transitions[key]

    # Create output with desired state keys and only states with a transition
    if all_keys:
        out = states
    else:
        out = states[["datestart", "datestop", "tstart", "tstop"] + list(state_keys)]
    out = out[has_transition]

    for dt in ("date", "t"):
        out[f"{dt}stop"][:-1] = out[f"{dt}start"][1:]
        out[f"{dt}stop"][-1] = states[f"{dt}stop"][-1]

    trans_keys_list = [TransKeysSet() for _ in range(len(out))]
    for key in state_keys:
        # Filter transitions for this key based on master filter (from creation of `out`).
        # Then get the index for these transitions.
        has_trans = has_transitions[key][has_transition]
        idxs = np.flatnonzero(has_trans)
        for idx in idxs:
            trans_keys_list[idx].add(key)

    # First state trans_keys is the transition keys from continuity.  Reduce
    # this by set intersection to the output state_keys.
    if "trans_keys" in states.colnames:
        trans_keys_list[0] = states["trans_keys"][0] & set(state_keys)

    out["trans_keys"] = trans_keys_list

    return out


def get_continuity(
    date=None, state_keys=None, lookbacks=(7, 30, 180, 1000), scenario=None
):
    """
    Get the state and transition dates at ``date`` for ``state_keys``.

    This function finds the state at a particular date by fetching commands
    prior to that date and determine the states.  It returns dictionary
    ``continuity`` provides the state values. Included in this dict is a special
    key ``__dates__`` which provides the corresponding date at which the
    state-changing command occurred.

    Since some state keys like ``pitch`` change often (many times per day) while
    others like ``letg`` may not change for weeks, this function does dynamic
    lookbacks from ``date`` to find transitions for each key.  By default it
    will try looking back 7 days, then 30 days, then 180 days, and finally 1000
    days.  This lookback sequence can be controlled with the ``lookbacks``
    argument.

    If ``state_keys`` is ``None`` then the default keys ``states.DEFAULT_STATE_KEYS``
    is used.  This corresponds to the "classic" Chandra commanded states (obsid,
    ACIS, PCAD, and mechanisms).

    :param date: date (DateTime compatible, default=NOW)
    :param state_keys: list of state keys or str (one state key) or None
    :param lookbacks: list of lookback times in days (default=[7, 30, 180, 1000])
    :param scenario: commands archive scenario (default=None)

    :returns: dict of state values
    """
    if isinstance(state_keys, str):
        state_keys = [state_keys]

    lookbacks = sorted(lookbacks)
    stop = DateTime(date)
    if state_keys is None:
        state_keys = DEFAULT_STATE_KEYS

    continuity = {}
    dates = {}

    # List of transitions that occur *after* the ``stop`` date but are still needed
    # to compute states.  Classic example is for maneuvers, but this also occurs for
    # SPMEnableTransition which puts commands into the future.  Collect all these
    # transitions and eventually add to the output continuity dict as the
    # __transitions__ key.  Then ``get_states`` uses this to initialize transitions.
    continuity_transitions = []

    for lookback in lookbacks:
        start = stop - lookback
        cmds = commands.get_cmds(start, stop, scenario=scenario)
        if len(cmds) == 0:
            continue

        for state_key in state_keys:
            # Don't bother if we already have a value for this key.
            if state_key in continuity:
                continue

            # Get available commanded states for this particular state_key.
            # This may return state values for many more keys (e.g.
            # PCAD-related), and some or all of these might be None if the
            # relevant command never happened.  Fill in continuity as possible
            # from last state (corresponding to the state after the last command
            # in cmds).
            try:
                # Note that we need to specify start and stop to ensure that the
                # states span the required time range. Without this the time
                # range of cmds is used which can give unexpected outputs if
                # ``date``` is within a maneuver.
                states = get_states(
                    state_keys=state_key,
                    cmds=cmds,
                    start=start,
                    stop=stop,
                    continuity={},
                    reduce=False,
                    scenario=scenario,
                )
            except NoTransitionsError:
                # No transitions within `cmds` for state_key, continue with other keys
                continue
            else:
                # get_states() sets this meta value with a list of transitions
                # that were beyond the stop time and did not get processed.
                continuity_transitions.extend(states.meta["continuity_transitions"])

            colnames = set(states.colnames) - set(
                ["datestart", "datestop", "tstart", "tstop", "trans_keys"]
            )
            for colname in colnames:
                if states[colname][-1] is not None:
                    # Reduce states to only the desired state_key
                    red_states = reduce_states(states, [colname])
                    continuity[colname] = red_states[colname][-1]
                    dates[colname] = red_states["datestart"][-1]

        # If we have filled in continuity for every key then we're done.
        # Otherwise bump the lookback and try again.
        if all(state_key in continuity for state_key in state_keys):
            break
    else:
        # Didn't find all state keys
        missing_keys = set(state_keys) - set(continuity)

        # Try to get defaults from transition classes
        for missing_key in missing_keys:
            for cls in get_transition_classes(missing_key):
                if hasattr(cls, "default_value"):
                    continuity[missing_key] = cls.default_value
                    dates[missing_key] = "DEFAULT"

        # Try again...
        missing_keys = set(state_keys) - set(continuity)
        if missing_keys:
            raise ValueError(
                "did not find transitions for state key(s)"
                " {} within {} days of {}.  Maybe adjust "
                "the `lookbacks` argument?".format(
                    missing_keys, lookbacks[-1], stop.date
                )
            )

    # Finally reduce down to the state_keys the user requested
    continuity = {key: continuity[key] for key in state_keys}
    dates = {key: dates[key] for key in state_keys}
    continuity["__dates__"] = dates

    # List of transitions needed to fully express continuity.  See long comment above.
    if continuity_transitions:
        continuity["__transitions__"] = continuity_transitions

    return continuity


def interpolate_states(states, times):
    """Interpolate ``states`` table at given times.

    :param states: states (astropy states Table)
    :param times: times (np.array or any DateTime compatible input)

    :returns: ``states`` view at ``times``
    """
    from astropy.table import Column

    if not isinstance(times, np.ndarray) or times.dtype.kind != "f":
        times = DateTime(times).secs

    try:
        tstops = states["tstop"]
    except (ValueError, KeyError):
        tstops = date2secs(states["datestop"])

    indexes = np.searchsorted(tstops, times)
    out = states[indexes]
    out.add_column(Column(secs2date(times), name="date"), index=0)

    return out


def _unique(seq):
    """Return unique elements of ``seq`` in order"""
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]


def print_state_keys_transition_classes_docs():
    """
    Sort transition classes into a data structure keyed by state_keys
    """
    state_keys_classes = collections.defaultdict(list)
    for cls in TRANSITION_CLASSES:
        keys = tuple(cls.state_keys)
        state_keys_classes[keys].append(cls)

    for keys in sorted(state_keys_classes):
        print(", ".join("``{}``".format(key) for key in keys))
        for cls in sorted(state_keys_classes[keys], key=lambda cls: cls.__name__):
            print("  - :class:`~{}.{}`".format(cls.__module__, cls.__name__))
        print()


def get_chandra_states(main_args=None):
    """
    Command line interface to output commanded states over a date range in tabular form
    to stdout or a file.
    """
    import argparse

    from astropy.io import ascii

    descr = (
        "Ouput the Chandra commanded states over a date range "
        "as a space-delimited ASCII table."
    )
    parser = argparse.ArgumentParser(description=descr)
    parser.add_argument("--start", help="Start date (default=Now-10 days)")
    parser.add_argument("--stop", help="Stop date (default=None)")
    parser.add_argument("--state-keys", help="Comma-separated list of state keys")
    parser.add_argument(
        "--merge-identical",
        default=False,
        action="store_true",
        help="Merge adjacent states that have identical values " "(default=False)",
    )
    parser.add_argument("--outfile", help="Output file (default=stdout)")

    opt = parser.parse_args(main_args)

    start = DateTime() - 10 if opt.start is None else DateTime(opt.start)
    stop = DateTime(opt.stop)
    state_keys = opt.state_keys.split(",") if opt.state_keys else None
    states = get_states(start, stop, state_keys, merge_identical=opt.merge_identical)
    del states["trans_keys"]
    del states["tstart"]
    del states["tstop"]

    ascii.write(states, output=opt.outfile, format="fixed_width", delimiter="")
